0000                             ; Tec-1F RAM build
0000                PGMSTART:   EQU   $2000   
0000                RAMSTART:   EQU   $3800   
0000                             ; TEC-1 I/O port addresses
0000                KEYBUF:   EQU   00H   ;MM74C923N keyboard encoder
0000                SCAN:     EQU   01H   ;display scan latch
0000                DISPLY:   EQU   02H   ;display latch
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (Relay Board) DATLATCH (DAT board)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (Dat board)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   
2000                          .ORG   PGMSTART   
2000   21 30 20               LD   HL,RxChar   
2003   22 42 3C               LD   (GETCVEC),HL   
2006   21 25 20               LD   HL,TxChar   
2009   22 44 3C               LD   (PUTCVEC),HL   
200C   CD 1C 20               CALL   InitialiseSerial   
200F   C3 39 20               JP   start   
2012                GETCHAR:      
2012   2A 42 3C               LD   HL,(GETCVEC)   
2015   E9                     JP   (HL)   
2016                PUTCHAR:      
2016   E5                     PUSH   HL   
2017   2A 44 3C               LD   HL,(PUTCVEC)   
201A   E3                     EX   (SP),HL   
201B   C9                     RET      
201C                             ;.include "BitBangSerial.asm"
201C                             ; 
201C                             ; 6850 ACIA registers
201C                             ;----------------------
201C                CONTROL:   EQU   $80   ;(write)
201C                STATUS:   EQU   $80   ;(read)
201C                TDR:      EQU   $81   ;(write)
201C                RDR:      EQU   $81   ;(read)
201C                             ; 
201C                             ; control register bits
201C                             ;----------------------
201C                             ; 
201C                             ;clock divisor
201C                             ; 
201C                MRESET:   EQU   $03   ;master reset the ACIA
201C                CLKDIV_0:   EQU   $00   ;CLOCK/1
201C                CLKDIV_16:   EQU   $01   ;CLOCK/16
201C                CLKDIV_64:   EQU   $02   ;CLOCK/64
201C                             ; 
201C                             ; format select
201C                             ; 
201C                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
201C                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
201C                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
201C                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
201C                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
201C                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
201C                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
201C                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
201C                             ; 
201C                             ; transmitter control
201C                             ; 
201C                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
201C                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
201C                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
201C                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
201C                             ; 
201C                             ; receiver interrupt
201C                             ; 
201C                RIE:      EQU   $80   ;receiver interrupt enabled
201C                             ; 
201C                             ; status register bits
201C                             ;---------------------
201C                RDRF:     EQU   0   ;receive data register full
201C                TDRE:     EQU   1   ;transmit data register empty
201C                DCD:      EQU   2   ;data carrier detect
201C                CTS:      EQU   3   ;clear to send
201C                FE:       EQU   4   ;framing error
201C                OVRN:     EQU   5   ;overrun
201C                PE:       EQU   6   ;parity error
201C                IRQ:      EQU   7   ;interrupt request
201C                             ; 
201C                             ; initialise ACIA
201C                             ;----------------
201C                INITIALISESERIAL:      
201C   3E 03                  LD   a,MRESET   
201E   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
2020                             ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
2020   3E 12                  LD   a,RTSLID+F8N2+CLKDIV_64   
2022   D3 80                  OUT   (CONTROL),a   
2024   C9                     RET      
2025                             ; 
2025                             ; transmit a character in a
2025                             ;--------------------------
2025                TXCHAR:      
2025   F5                     PUSH   af   ;save the character for later
2026                TXCHAR1:      
2026   DB 80                  IN   a,(STATUS)   ;get the ACIA status
2028   CB 4F                  BIT   1,a   ;bit   TDRE,a is the TDRE bit high?
202A   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
202C   F1                     POP   af   ;yes, get the character back
202D   D3 81                  OUT   (TDR),a   ;and put it in the TDR
202F   C9                     RET      
2030                             ; 
2030                             ; receive  a character in a
2030                             ;---------------------------------
2030                RXCHAR:      
2030   DB 80                  IN   a,(STATUS)   ;get the ACIA status
2032   CB 47                  BIT   0,a   ;bit   RDRF,a is the RDRF bit high?
2034   28 FA                  JR   z,RxChar   ;no, the RDR is empty
2036   DB 81                  IN   a,(RDR)   ;yes, read the received char
2038   C9                     RET      
2039                             ;.include "RC2014-6850.asm"
2039                             ; *************************************************************************
2039                             ; 
2039                             ;        MINT1_18 Micro-Interpreter for the Z80
2039                             ; 
2039                             ;        Ken Boak John Hardy and Craig Jones  December 2nd 2021
2039                             ; 
2039                             ;		 Multiplication stack bug fixed
2039                             ; 
2039                             ;        Comparison Operators < and > return 0 (false) when equality is detected
2039                             ;        Printhex routine shortened
2039                             ; 
2039                             ; 
2039                             ;        Hex entry bug fixed 28-11-21
2039                             ;        Decimal entry bug fixed  24-11-21
2039                             ;        Division routine shortened by 13 bytes 24/11
2039                             ; 
2039                             ; 
2039                             ;        Includes serial routines getchar and putchar
2039                             ;        printstring
2039                             ;        printdec
2039                             ;        printhex
2039                             ;        crlf
2039                             ; 
2039                             ;        Register Assignment:
2039                             ; 
2039                             ;        BC is the instruction pointer IP
2039                             ;        DE is a working register and 2nd on stack NOS
2039                             ;        HL is a working register and Top of stack TOS
2039                             ;        SP is data stack pointer
2039                             ;        IX is used to implement the return stack
2039                             ;        IY is used as a jump back to NEXT
2039                             ; 
2039                             ;        All commands accessed via a byte wide look up table
2039                             ; 
2039                             ;        Heap used for command storage (HERE)
2039                             ; 
2039                             ;        Primitives are on two consecutive pages using a trampoline jump to the 2nd page.
2039                             ; 
2039                             ;        This allows single byte opcodes reducing the dispatch time from
2039                             ;        64 t states to 33 t states
2039                             ; 
2039                             ; 
2039                             ;        User defined commands and mintVars
2039                             ; 
2039                             ;        User Commands  A-Z
2039                             ;        User mintVars a-z
2039                             ; 
2039                             ;        Commands now available:
2039                             ; 
2039                             ;        Maths
2039                             ; 
2039                             ;        +     ADD
2039                             ;		 -     SUB
2039                             ;        *     MUL     (max product 65535)
2039                             ;        /     DIV     Returns quotient and remainder
2039                             ;        _     NEG
2039                             ; 
2039                             ;        }     Shift Right (2/)
2039                             ;        {     Shift Left  (2*)
2039                             ; 
2039                             ;        Comparison - compare the top two elements on the stack
2039                             ;        Puts 1 on the stack if condition is true, 0 if false
2039                             ; 
2039                             ;        <     LT
2039                             ;        =     EQ
2039                             ;        >     GT
2039                             ; 
2039                             ;        Logic
2039                             ; 
2039                             ;        &     AND
2039                             ;        |     OR
2039                             ;        ^     XOR
2039                             ;        ~     INV
2039                             ; 
2039                             ;        Stack
2039                             ; 
2039                             ;        "     DUP
2039                             ;        '     DROP
2039                             ;        $     SWAP
2039                             ;		 %     OVER
2039                             ;        .     DOT     (Print the value of the top of stack as a decimal)
2039                             ;        ,     COMMA   (Print the value of the top of stack as a hexadecimal)
2039                             ;		 #     HEX     Accept a hexadecimal number
2039                             ; 
2039                             ;        Memory
2039                             ; 
2039                             ;        @     FETCH
2039                             ;        !     STORE
2039                             ; 
2039                             ;        User Definitions
2039                             ; 
2039                             ;        :     Start a user definition
2039                             ;        ;     End a user definition
2039                             ; 
2039                             ;        \     QUIT    (Print OK and return to monitor)
2039                             ; 
2039                             ; 
2039                             ;        Loops    - execute the code between parenthesis
2039                             ; 
2039                             ;        The user variable i is used as the loop counter
2039                             ;        It is decremented every time the loop is executed
2039                             ; 
2039                             ;        10(repeat this code 10 times)
2039                             ; 
2039                             ;        0(skip this code)
2039                             ; 
2039                             ;        1(execute this code only once)
2039                             ; 
2039                             ;        a@ b@ = (_print this if a=b_)
2039                             ; 
2039                             ;       1000(i@.)    Print out the value of i from 999 to 0
2039                             ; 
2039                             ;       10(a@ 1+ a! a@ .)  Increment a 10 times and print it out
2039                             ; 
2039                             ;       User Commands are allocated to uppercase alpha characters A to Z
2039                             ; 
2039                             ;       A user command can be defined by starting with a colon and
2039                             ;       ending with a semicolon
2039                             ; 
2039                             ;       Example  :A 123 456 + . ;
2039                             ; 
2039                             ;       The A character represents a fixed address for the User routine
2039                             ;       The interpreter copies all the characters after the A to a text buffer
2039                             ;       located at address A
2039                             ;       Each time A is encountered (outside of a colon definition)
2039                             ;       it will execute the code  located there i.e. 123 456 + .
2039                             ; 
2039                             ;       mintVars are associated with lowercase characters a-z
2039                             ;       Each variable is allocated 2 bytes located on even addresses
2039                             ;       They run contiguously from $A800 (a) to $A830 (z)
2039                             ;       They are accessed using the fetch and store commands @ and !
2039                             ; 
2039                             ;       Examples:
2039                             ; 
2039                             ;       1234 a!     store 1234 in a
2039                             ; 
2039                             ;       b@ .        fetch the value from b and print it out
2039                             ; 
2039                             ;       a@ b@ + .   fetch values from a and b, add them together and print the sum
2039                             ; 
2039                             ;       a@ b!       copy the value in a and store it in b
2039                             ; 
2039                             ; 
2039                             ; *****************************************************************************
2039                             ;ROMSTART    EQU $0
2039                             ;RAMSTART    EQU $800
2039                             ;EXTENDED    EQU 0
2039                             ;ROMSIZE     EQU $800
2039                DSIZE:    EQU   $100   
2039                RSIZE:    EQU   $100   
2039                TIBSIZE:   EQU   $100   
2039                TRUE:     EQU   1   
2039                FALSE:    EQU   0   
2039                             ;        .ORG ROMSTART
2039                             ; 
2039                             ; **************************************************************************
2039                             ; Page 0  Initialisation
2039                             ; **************************************************************************		
2039                             ;        JP start
2039                             ;		.ORG ROMSTART + $180		
2039                START:       
2039                MINT:        
2039   31 00 39               LD   SP,DSTACK   
203C   CD 53 20               CALL   initialize   
203F   CD EC 20               CALL   ENTER   
2042   60 4D 49 4E 54 20 56 31 2E 30 60 5C 4E 00 .CSTR   "`MINT V1.0`\\N"   
2050   C3 74 20               JP   interpret   
2053                INITIALIZE:      
2053   DD 21 00 3A            LD   IX,RSTACK   
2057   FD 21 D3 20            LD   IY,NEXT   ; IY provides a faster jump to NEXT
205B   21 60 22               LD   HL,iSysConsts   
205E   11 00 3B               LD   DE,sysConsts   
2061   01 20 00               LD   BC,16 * 2   
2064   ED B0                  LDIR      
2066   21 78 3B               LD   HL,defs   
2069   06 1A                  LD   B,26   
206B                INIT1:       
206B   36 51                  LD   (HL),lsb(empty_)   
206D   23                     INC   HL   
206E   36 21                  LD   (HL),msb(empty_)   
2070   23                     INC   HL   
2071   10 F8                  DJNZ   init1   
2073   C9                     RET      
2074                INTERPRET:      
2074   CD EC 20               CALL   ENTER   
2077   5C 4E 60 3E 20 60 00   .CSTR   "\\N`> `"   
207E                INTERPRET1:      ; used by tests
207E   01 00 00               LD   BC,0   ; load BC with offset into TIB
2081   ED 43 14 3B            LD   (vTIBPtr),BC   
2085                INTERPRET2:      ; calc nesting (a macro might have changed it)
2085   1E 00                  LD   E,0   ; initilize nesting value
2087   C5                     PUSH   BC   ; save offset into TIB,
2088                             ; BC is also the count of chars in TIB
2088   21 00 3A               LD   HL,TIB   ; HL is start of TIB
208B   18 06                  JR   interpret4   
208D                INTERPRET3:      
208D   7E                     LD   A,(HL)   ; A = char in TIB
208E   23                     INC   HL   ; inc pointer into TIB
208F   0B                     DEC   BC   ; dec count of chars in TIB
2090   CD CD 26               CALL   nesting   ; update nesting value
2093                INTERPRET4:      
2093   79                     LD   A,C   ; is count zero?
2094   B0                     OR   B   
2095   20 F6                  JR   NZ,interpret3   ; if not loop
2097   C1                     POP   BC   ; restore offset into TIB
2098                             ; *******************************************************************
2098                             ; Wait for a character from the serial input (keyboard)
2098                             ; and store it in the text buffer. Keep accepting characters,
2098                             ; increasing the instruction pointer BC - until a newline received.
2098                             ; *******************************************************************
2098                WAITCHAR:      
2098   CD 12 20               CALL   getchar   ; loop around waiting for character
209B   FE 20                  CP   $20   
209D   30 0D                  JR   NC,waitchar1   
209F   FE 00                  CP   $0   ; is it end of string?
20A1   28 28                  JR   Z,waitchar4   
20A3   FE 0D                  CP   "\r"   ; carriage return?
20A5   28 13                  JR   Z,waitchar3   
20A7   16 00                  LD   D,0   
20A9   C3 37 21               JP   macro   
20AC                WAITCHAR1:      
20AC   21 00 3A               LD   HL,TIB   
20AF   09                     ADD   HL,BC   
20B0   77                     LD   (HL),A   ; store the character in textbuf
20B1   03                     INC   BC   
20B2   CD 16 20               CALL   putchar   ; echo character to screen
20B5   CD CD 26               CALL   nesting   
20B8   18 DE                  JR   waitchar   ; wait for next character
20BA                WAITCHAR3:      
20BA   21 00 3A               LD   HL,TIB   
20BD   09                     ADD   HL,BC   
20BE   36 0D                  LD   (HL),"\r"   ; store the crlf in textbuf
20C0   03                     INC   BC   
20C1   CD EA 24               CALL   crlf   ; echo character to screen
20C4   7B                     LD   A,E   ; if zero nesting append and ETX after \r
20C5   B7                     OR   A   
20C6   20 D0                  JR   NZ,waitchar   
20C8   36 03                  LD   (HL),$03   ; store end of text ETX in text buffer
20CA   03                     INC   BC   
20CB                WAITCHAR4:      
20CB   ED 43 14 3B            LD   (vTIBPtr),BC   
20CF   01 00 3A               LD   BC,TIB   ; Instructions stored on heap at address HERE
20D2   0B                     DEC   BC   
20D3                             ; Drop into the NEXT and dispatch routines
20D3                             ; ********************************************************************************
20D3                             ; 
20D3                             ; Dispatch Routine.
20D3                             ; 
20D3                             ; Get the next character and form a 1 byte jump address
20D3                             ; 
20D3                             ; This target jump address is loaded into HL, and using JP (HL) to quickly
20D3                             ; jump to the selected function.
20D3                             ; 
20D3                             ; Individual handler routines will deal with each category:
20D3                             ; 
20D3                             ; 1. Detect characters A-Z and jump to the User Command handler routine
20D3                             ; 
20D3                             ; 2. Detect characters a-z and jump to the variable handler routine
20D3                             ; 
20D3                             ; 3. All other characters are punctuation and cause a jump to the associated
20D3                             ; primitive code.
20D3                             ; 
20D3                             ; Instruction Pointer IP BC is incremented
20D3                             ; 
20D3                             ; *********************************************************************************
20D3                NEXT:        
20D3   03                     INC   BC   ; 6t    Increment the IP
20D4   0A                     LD   A,(BC)   ; 7t    Get the next character and dispatch
20D5                             ; 
20D5                DISPATCH:      
20D5   FE 00                  CP   0   ;       NULL? exit Mint
20D7   CA 6A 23               JP   Z,exit_   
20DA   FE 03                  CP   $03   ;       ETX? interpret next line
20DC   CA 74 20               JP   Z,interpret   
20DF   D6 20                  SUB   " "   ; 7t    remove char offset
20E1   38 F0                  JR   C,NEXT   ;       ignore char
20E3   11 00 22               LD   DE,opcodes   ; 7t    Start address of jump table
20E6   5F                     LD   E,A   ; 4t    Index into table
20E7   1A                     LD   A,(DE)   ; 7t    get low jump address
20E8   26 23                  LD   H,msb(page4)   ; 7t    Load H with the 1st page address
20EA   6F                     LD   L,A   ; 4t    and put into L
20EB   E9                     JP   (HL)   ; 4t    Jump to routine
20EC                ENTER:       
20EC   60 69                  LD   HL,BC   
20EE   CD D4 24               CALL   rpush   ; save Instruction Pointer
20F1   C1                     POP   BC   
20F2   0B                     DEC   BC   
20F3   FD E9                  JP   (IY)   ; Execute code from User def
20F5                PRINTDEC:      
20F5                             ;Number in hl to decimal ASCII
20F5                             ;inputs:	hl = number to ASCII
20F5                             ;example: hl=300 outputs "00300"
20F5                             ;destroys: af, de, hl
20F5                DISPHL:      
20F5   11 F0 D8               LD   de,-10000   
20F8   CD 0E 21               CALL   Num1   
20FB   11 18 FC               LD   de,-1000   
20FE   CD 0E 21               CALL   Num1   
2101   11 9C FF               LD   de,-100   
2104   CD 0E 21               CALL   Num1   
2107   1E F6                  LD   e,-10   
2109   CD 0E 21               CALL   Num1   
210C   1E FF                  LD   e,-1   
210E                NUM1:        
210E   3E 2F                  LD   a,"0"-1   
2110                NUM2:        
2110   3C                     INC   a   
2111   19                     ADD   hl,de   
2112   38 FC                  JR   c,Num2   
2114   ED 52                  SBC   hl,de   
2116   C3 16 20               JP   putchar   
2119                             ; ARRAY compilation routine
2119                COMPNEXT:      
2119   D1                     POP   DE   ; DE = return address
211A   2A 1E 3B               LD   HL,(vHeapPtr)   ; load heap ptr
211D   73                     LD   (HL),E   ; store lsb
211E   3A 2E 3C               LD   A,(vByteMode)   
2121   23                     INC   HL   
2122   B7                     OR   A   
2123   20 02                  JR   NZ,compNext1   
2125   72                     LD   (HL),D   
2126   23                     INC   HL   
2127                COMPNEXT1:      
2127   22 1E 3B               LD   (vHeapPtr),HL   ; save heap ptr
212A   C3 D3 20               JP   NEXT   
212D                SPACE:       
212D   3E 20                  LD   A," "   
212F   C3 16 20               JP   putchar   
2132                WRITECHAR:      
2132   12                     LD   (DE),A   
2133   13                     INC   DE   
2134   C3 16 20               JP   putchar   
2137                MACRO:       
2137   ED 43 14 3B            LD   (vTIBPtr),BC   
213B   21 80 22               LD   HL,ctrlCodes   
213E   85                     ADD   A,L   
213F   6F                     LD   L,A   
2140   5E                     LD   E,(HL)   
2141   16 21                  LD   D,msb(macros)   
2143   D5                     PUSH   DE   
2144   CD EC 20               CALL   ENTER   
2147   5C 47 00               .CSTR   "\\G"   
214A   ED 4B 14 3B            LD   BC,(vTIBPtr)   
214E   C3 85 20               JP   interpret2   
2151                             ; **************************************************************************
2151                             ; Macros must be written in Mint and end with ;
2151                             ; this code must not span pages
2151                             ; **************************************************************************
2151                MACROS:      
2151                EMPTY_:      
2151   3B 00                  .CSTR   ";"   
2153                BACKSP_:      
2153   5C 63 40 30 3D 30 3D 28 31 5F 5C 63 5C 2B 38 5C 45 60 20 60 38 5C 45 29 3B 00 .CSTR   "\\c@0=0=(1_\\c\\+8\\E` `8\\E);"   
216D                EDIT_:       
216D   60 3F 60 5C 4B 5C 4E 60 3E 20 60 5C 5E 41 2D 5C 5A 3B 00 .CSTR   "`?`\\K\\N`> `\\^A-\\Z;"   
2180                LIST_:       
2180   5C 4E 32 36 28 5C 69 40 5C 5A 5C 63 40 30 3E 28 5C 4E 29 29 5C 4E 60 3E 20 60 3B 00 .CSTR   "\\N26(\\i@\\Z\\c@0>(\\N))\\N`> `;"   
219C                PRINTSTACK_:      
219C   60 3D 3E 20 60 5C 50 5C 4E 5C 4E 60 3E 20 60 3B 00 .CSTR   "`=> `\\P\\N\\N`> `;"   
21AD                TOGGLEBASE_:      
21AD   5C 62 40 30 3D 5C 62 21 3B 00 .CSTR   "\\b@0=\\b!;"   
21B7                             ; **************************************************************************
21B7                             ; Page 2  Jump Tables
21B7                             ; **************************************************************************
21B7                          ALIGN   $100   
2200                OPCODES:      
2200   86                     DB   lsb(nop_)   ;    SP
2201   9B                     DB   lsb(store_)   ;    !
2202   65                     DB   lsb(dup_)   ;    "
2203   7B                     DB   lsb(hex_)   ;    #
2204   A2                     DB   lsb(swap_)   ;    $
2205   8C                     DB   lsb(over_)   ;    %
2206   04                     DB   lsb(and_)   ;    &
2207   62                     DB   lsb(drop_)   ;    '
2208   32                     DB   lsb(begin_)   ;    (
2209   EF                     DB   lsb(again_)   ;    )
220A   F1                     DB   lsb(mul_)   ;    *
220B   26                     DB   lsb(add_)   ;    +
220C   80                     DB   lsb(hexp_)   ;    ,
220D   BA                     DB   lsb(sub_)   ;    -
220E   4E                     DB   lsb(dot_)   ;    .
220F   F3                     DB   lsb(div_)   ;    /
2210   89                     DB   lsb(num_)   ;    0
2211   89                     DB   lsb(num_)   ;    1
2212   89                     DB   lsb(num_)   ;    2
2213   89                     DB   lsb(num_)   ;    3
2214   89                     DB   lsb(num_)   ;    4
2215   89                     DB   lsb(num_)   ;    5
2216   89                     DB   lsb(num_)   ;    6
2217   89                     DB   lsb(num_)   ;    7
2218   89                     DB   lsb(num_)   ;    8
2219   89                     DB   lsb(num_)   ;    9
221A   4B                     DB   lsb(def_)   ;    :
221B   94                     DB   lsb(ret_)   ;    ;
221C   D2                     DB   lsb(lt_)   ;    <
221D   C2                     DB   lsb(eq_)   ;    =
221E   CE                     DB   lsb(gt_)   ;    >
221F   F5                     DB   lsb(getRef_)   ;    ?
2220   74                     DB   lsb(fetch_)   ;    @
2221   35                     DB   lsb(call_)   ;    A
2222   35                     DB   lsb(call_)   ;    B
2223   35                     DB   lsb(call_)   ;    C
2224   35                     DB   lsb(call_)   ;    D
2225   35                     DB   lsb(call_)   ;    E
2226   35                     DB   lsb(call_)   ;    F
2227   35                     DB   lsb(call_)   ;    G
2228   35                     DB   lsb(call_)   ;    H
2229   35                     DB   lsb(call_)   ;    I
222A   35                     DB   lsb(call_)   ;    J
222B   35                     DB   lsb(call_)   ;    K
222C   35                     DB   lsb(call_)   ;    L
222D   35                     DB   lsb(call_)   ;    M
222E   35                     DB   lsb(call_)   ;    N
222F   35                     DB   lsb(call_)   ;    O
2230   35                     DB   lsb(call_)   ;    P
2231   35                     DB   lsb(call_)   ;    Q
2232   35                     DB   lsb(call_)   ;    R
2233   35                     DB   lsb(call_)   ;    S
2234   35                     DB   lsb(call_)   ;    T
2235   35                     DB   lsb(call_)   ;    U
2236   35                     DB   lsb(call_)   ;    V
2237   35                     DB   lsb(call_)   ;    W
2238   35                     DB   lsb(call_)   ;    X
2239   35                     DB   lsb(call_)   ;    Y
223A   35                     DB   lsb(call_)   ;    Z
223B   2C                     DB   lsb(arrDef_)   ;    [
223C   00                     DB   lsb(alt_)   ;    \
223D   2F                     DB   lsb(arrEnd_)   ;    ]
223E   18                     DB   lsb(xor_)   ;    ^
223F   B4                     DB   lsb(neg_)   ;    _
2240   ED                     DB   lsb(str_)   ;    `
2241   E3                     DB   lsb(var_)   ;    a
2242   E3                     DB   lsb(var_)   ;    b
2243   E3                     DB   lsb(var_)   ;    c
2244   E3                     DB   lsb(var_)   ;    d
2245   E3                     DB   lsb(var_)   ;    e
2246   E3                     DB   lsb(var_)   ;    f
2247   E3                     DB   lsb(var_)   ;    g
2248   E3                     DB   lsb(var_)   ;    h
2249   E3                     DB   lsb(var_)   ;    i
224A   E3                     DB   lsb(var_)   ;    j
224B   E3                     DB   lsb(var_)   ;    k
224C   E3                     DB   lsb(var_)   ;    l
224D   E3                     DB   lsb(var_)   ;    m
224E   E3                     DB   lsb(var_)   ;    n
224F   E3                     DB   lsb(var_)   ;    o
2250   E3                     DB   lsb(var_)   ;    p
2251   E3                     DB   lsb(var_)   ;    q
2252   E3                     DB   lsb(var_)   ;    r
2253   E3                     DB   lsb(var_)   ;    s
2254   E3                     DB   lsb(var_)   ;    t
2255   E3                     DB   lsb(var_)   ;    u
2256   E3                     DB   lsb(var_)   ;    v
2257   E3                     DB   lsb(var_)   ;    w
2258   E3                     DB   lsb(var_)   ;    x
2259   E3                     DB   lsb(var_)   ;    y
225A   E3                     DB   lsb(var_)   ;    z
225B   A7                     DB   lsb(shl_)   ;    {
225C   0F                     DB   lsb(or_)   ;    |
225D   AC                     DB   lsb(shr_)   ;    }
225E   21                     DB   lsb(inv_)   ;    ~
225F   86                     DB   lsb(nop_)   ;    backspace
2260                             ; ***********************************************************************
2260                             ; Initial values for user mintVars		
2260                             ; ***********************************************************************		
2260                ISYSCONSTS:      
2260   00 39                  DW   dStack   ; \0 cS0
2262   00 3A                  DW   TIB   ; \1 cTIB
2264   78 3B                  DW   defs   ; \2 cDefs
2266   44 3B                  DW   vars   ; \3 cVars
2268   00 22                  DW   opcodes   ; \4 cOpcodes
226A   51 21                  DW   macros   ; \5 cMacros
226C   10 3B                  DW   userVars   ; \6 cUserVars
226E   00 00                  DW   0   ; \7
2270                IUSERVARS:      
2270   F4 24                  DW   alt1   ; a vAltCodes
2272   00 00                  DW   FALSE   ; b vBase16
2274   00 00                  DW   0   ; c vTIBPtr
2276   00 00                  DW   0   ; d putChar
2278   00 00                  DW   0   ; e enter
227A   00 00                  DW   0   ; f vIFTEMode
227C   00 00                  DW   0   ; g vByteMode
227E   80 3C                  DW   HEAP   ; h vHeapPtr
2280                             ; ***********************************************************************
2280                             ; Alternate function codes		
2280                             ; ***********************************************************************		
2280                CTRLCODES:      
2280                ALTCODES:      
2280   51                     DB   lsb(empty_)   ; NUL ^@
2281   51                     DB   lsb(empty_)   ; SOH ^A
2282   AD                     DB   lsb(toggleBase_)   ; STX ^B
2283   51                     DB   lsb(empty_)   ; ETX ^C
2284   51                     DB   lsb(empty_)   ; EOT ^D
2285   6D                     DB   lsb(edit_)   ; ENQ ^E
2286   51                     DB   lsb(empty_)   ; ACK ^F
2287   51                     DB   lsb(empty_)   ; BEL ^G
2288   53                     DB   lsb(backsp_)   ; BS  ^H
2289   51                     DB   lsb(empty_)   ; TAB ^I
228A   51                     DB   lsb(empty_)   ; LF  ^J
228B   51                     DB   lsb(empty_)   ; VT  ^K
228C   80                     DB   lsb(list_)   ; FF  ^L
228D   51                     DB   lsb(empty_)   ; CR  ^M
228E   51                     DB   lsb(empty_)   ; SO  ^N
228F   51                     DB   lsb(empty_)   ; SI  ^O
2290   9C                     DB   lsb(printStack_)   ; DLE ^P
2291   51                     DB   lsb(empty_)   ; DC1 ^Q
2292   51                     DB   lsb(empty_)   ; DC2 ^R
2293   51                     DB   lsb(empty_)   ; DC3 ^S
2294   51                     DB   lsb(empty_)   ; DC4 ^T
2295   51                     DB   lsb(empty_)   ; NAK ^U
2296   51                     DB   lsb(empty_)   ; SYN ^V
2297   51                     DB   lsb(empty_)   ; ETB ^W
2298   51                     DB   lsb(empty_)   ; CAN ^X
2299   51                     DB   lsb(empty_)   ; EM  ^Y
229A   51                     DB   lsb(empty_)   ; SUB ^Z
229B   51                     DB   lsb(empty_)   ; ESC ^[
229C   51                     DB   lsb(empty_)   ; FS  ^\
229D   51                     DB   lsb(empty_)   ; GS  ^]
229E   51                     DB   lsb(empty_)   ; RS  ^^
229F   51                     DB   lsb(empty_)   ; US  ^_)
22A0   0A                     DB   lsb(aNop_)   ; SP  ^`
22A1   1D                     DB   lsb(cStore_)   ;    !
22A2   0A                     DB   lsb(aNop_)   ;    "
22A3   0A                     DB   lsb(aNop_)   ;    #
22A4   0A                     DB   lsb(aNop_)   ;    $  ( -- adr ) text input ptr
22A5   0A                     DB   lsb(aNop_)   ;    %
22A6   0A                     DB   lsb(aNop_)   ;    &
22A7   0A                     DB   lsb(aNop_)   ;    '
22A8   3B                     DB   lsb(ifte_)   ;    (
22A9   0A                     DB   lsb(aNop_)   ;    )
22AA   0A                     DB   lsb(aNop_)   ;    *
22AB   6C                     DB   lsb(incr_)   ;    +  ( adr -- ) decrements variable at address
22AC   0A                     DB   lsb(aNop_)   ;    ,
22AD   0A                     DB   lsb(aNop_)   ;    -
22AE   0A                     DB   lsb(aNop_)   ;    .
22AF   0A                     DB   lsb(aNop_)   ;    /
22B0   93                     DB   lsb(sysConst_)   ;    0  ( -- adr ) start of data stack constant
22B1   93                     DB   lsb(sysConst_)   ;    1  ; returns HERE variable
22B2   93                     DB   lsb(sysConst_)   ;    2  ( -- adr ) TIBPtr variable
22B3   93                     DB   lsb(sysConst_)   ;    3  ( -- adr ) isHex variable
22B4   93                     DB   lsb(sysConst_)   ;    4
22B5   93                     DB   lsb(sysConst_)   ;    5
22B6   93                     DB   lsb(sysConst_)   ;    6
22B7   93                     DB   lsb(sysConst_)   ;    7
22B8   0A                     DB   lsb(aNop_)   ;    8
22B9   0A                     DB   lsb(aNop_)   ;    9
22BA   0A                     DB   lsb(aNop_)   ;    :  start defining a macro
22BB   0A                     DB   lsb(aNop_)   ;    ;
22BC   0A                     DB   lsb(aNop_)   ;    <
22BD   0A                     DB   lsb(aNop_)   ;    =
22BE   0A                     DB   lsb(aNop_)   ;    >
22BF   0A                     DB   lsb(aNop_)   ;    ?
22C0   05                     DB   lsb(cFetch_)   ;    @
22C1   0A                     DB   lsb(aNop_)   ;    A
22C2   0A                     DB   lsb(aNop_)   ;    B
22C3   86                     DB   lsb(nop_)   ;    C
22C4   22                     DB   lsb(depth_)   ;    D  ( -- val ) depth of data stack
22C5   34                     DB   lsb(emit_)   ;    E   ( val -- ) emits a char to output
22C6   0A                     DB   lsb(aNop_)   ;    F
22C7   55                     DB   lsb(go_)   ;    G   ( -- ? ) execute mint definition
22C8   0A                     DB   lsb(aNop_)   ;    H
22C9   77                     DB   lsb(inPort_)   ;    I  ( port -- val )
22CA   0A                     DB   lsb(aNop_)   ;    J
22CB   8A                     DB   lsb(key_)   ;    K  ( -- val )  read a char from input
22CC   9E                     DB   lsb(least_)   ;    L  ( a b -- c ) return the smallest value
22CD   A6                     DB   lsb(most_)   ;    M  ( a b -- c ) return the largest value
22CE   B2                     DB   lsb(newln_)   ;    N   ; prints a newline to output
22CF   B7                     DB   lsb(outPort_)   ;    O  ( val port -- )
22D0   E2                     DB   lsb(printStk_)   ;    P  ( -- ) non-destructively prints stack
22D1   93                     DB   lsb(quit_)   ;    Q  quits from Mint REPL
22D2   BE                     DB   lsb(rot_)   ;    R  ( a b c -- b c a )
22D3   0A                     DB   lsb(aNop_)   ;    S
22D4   0A                     DB   lsb(aNop_)   ;    T
22D5   0A                     DB   lsb(aNop_)   ;    U
22D6   0A                     DB   lsb(aNop_)   ;    V
22D7   D1                     DB   lsb(while_)   ;    W   ; ( b -- ) if false, skip to end of loop
22D8   4D                     DB   lsb(exec_)   ;    X
22D9   0A                     DB   lsb(aNop_)   ;    Y
22DA   E0                     DB   lsb(editDef_)   ;    Z
22DB   00                     DB   lsb(cArrDef_)   ;    [
22DC   14                     DB   lsb(comment_)   ;    \  comment text, skips reading until end of line
22DD   0A                     DB   lsb(aNop_)   ;    ]
22DE   0C                     DB   lsb(charCode_)   ;    ^
22DF   C5                     DB   lsb(sign_)   ;    _)  ( n -- b ) returns true if -ve
22E0   0A                     DB   lsb(aNop_)   ;    `
22E1   5E                     DB   lsb(userVar_)   ;    a
22E2   5E                     DB   lsb(userVar_)   ;    b  ; base16 variable
22E3   5E                     DB   lsb(userVar_)   ;    c  ; TIBPtr variable
22E4   5E                     DB   lsb(userVar_)   ;    d
22E5   5E                     DB   lsb(userVar_)   ;    e
22E6   5E                     DB   lsb(userVar_)   ;    f
22E7   5E                     DB   lsb(userVar_)   ;    g
22E8   5E                     DB   lsb(userVar_)   ;    h  ; heap ptr variable
22E9   68                     DB   lsb(i_)   ;    i  ; returns index variable of current loop
22EA   80                     DB   lsb(j_)   ;    j  ; returns index variable of outer loop
22EB   5E                     DB   lsb(userVar_)   ;    k
22EC   5E                     DB   lsb(userVar_)   ;    l
22ED   5E                     DB   lsb(userVar_)   ;    m  ( a b -- c ) return the minimum value
22EE   5E                     DB   lsb(userVar_)   ;    n
22EF   5E                     DB   lsb(userVar_)   ;    o
22F0   5E                     DB   lsb(userVar_)   ;    p
22F1   5E                     DB   lsb(userVar_)   ;    q
22F2   5E                     DB   lsb(userVar_)   ;    r
22F3   5E                     DB   lsb(userVar_)   ;    s
22F4   5E                     DB   lsb(userVar_)   ;    t
22F5   5E                     DB   lsb(userVar_)   ;    u
22F6   5E                     DB   lsb(userVar_)   ;    v
22F7   5E                     DB   lsb(userVar_)   ;    w
22F8   5E                     DB   lsb(userVar_)   ;    x
22F9   5E                     DB   lsb(userVar_)   ;    y
22FA   5E                     DB   lsb(userVar_)   ;    z
22FB   0A                     DB   lsb(aNop_)   ;    {
22FC   0A                     DB   lsb(aNop_)   ;    |
22FD   0A                     DB   lsb(aNop_)   ;    }
22FE   0A                     DB   lsb(aNop_)   ;    ~
22FF   0A                     DB   lsb(aNop_)   ;    BS		
2300                             ; **********************************************************************			
2300                             ; Page 4 primitive routines
2300                             ; **********************************************************************
2300                          ALIGN   $100   
2300                PAGE4:       
2300                ALT_:        
2300   2A 10 3B               LD   HL,(vAlt)   
2303   E9                     JP   (HL)   
2304                AND_:        
2304   D1                     POP   DE   ; 10t Bitwise AND the top 2 elements of the stack
2305   E1                     POP   HL   ; 10t
2306   7B                     LD   A,E   ; 4t
2307   A5                     AND   L   ; 4t
2308   6F                     LD   L,A   ; 4t
2309   7A                     LD   A,D   ; 4t
230A   A4                     AND   H   ; 4t
230B                AND1:        
230B   67                     LD   H,A   ; 4t
230C   E5                     PUSH   HL   ; 11t
230D   FD E9                  JP   (IY)   ; 8t
230F                             ; 63t
230F                OR_:         
230F   D1                     POP   DE   ; Bitwise OR the top 2 elements of the stack
2310   E1                     POP   HL   
2311   7B                     LD   A,E   
2312   B5                     OR   L   
2313   6F                     LD   L,A   
2314   7A                     LD   A,D   
2315   B4                     OR   H   
2316   18 F3                  JR   and1   
2318                XOR_:        
2318   D1                     POP   DE   ; Bitwise XOR the top 2 elements of the stack
2319                XOR1:        
2319   E1                     POP   HL   
231A   7B                     LD   A,E   
231B   AD                     XOR   L   
231C   6F                     LD   L,A   
231D   7A                     LD   A,D   
231E   AC                     XOR   H   
231F   18 EA                  JR   and1   
2321                INV_:        ; Bitwise INVert the top member of the stack
2321   11 FF FF               LD   DE,$FFFF   ; by xoring with $FFFF
2324   18 F3                  JR   xor1   
2326                ADD_:        ; Add the top 2 members of the stack
2326   D1                     POP   DE   ; 10t
2327   E1                     POP   HL   ; 10t
2328   19                     ADD   HL,DE   ; 11t
2329   E5                     PUSH   HL   ; 11t
232A   FD E9                  JP   (IY)   ; 8t
232C                             ; 50t
232C   C3 3D 26     ARRDEF_:   JP   arrDef   
232F   C3 4F 26     ARREND_:   JP   arrEnd   
2332   C3 7F 24     BEGIN_:   JP   begin   
2335                CALL_:       
2335   60 69                  LD   HL,BC   
2337   CD D4 24               CALL   rpush   ; save Instruction Pointer
233A   0A                     LD   A,(BC)   
233B   D6 41                  SUB   "A"   ; Calc index
233D   87                     ADD   A,A   
233E   21 78 3B               LD   HL,DEFS   
2341   5F                     LD   E,A   
2342   16 00                  LD   D,0   
2344   19                     ADD   HL,DE   
2345   4E                     LD   C,(HL)   
2346   23                     INC   HL   
2347   46                     LD   B,(HL)   
2348   0B                     DEC   BC   
2349   FD E9                  JP   (IY)   ; Execute code from User def
234B   C3 6B 26     DEF_:     JP   def   
234E                DOT_:        
234E   E1                     POP   HL   
234F   3A 12 3B               LD   A,(vBase16)   
2352   B7                     OR   A   
2353   28 05                  JR   Z,dot1   
2355   CD AE 26               CALL   printhex   
2358   18 03                  JR   dot2   
235A                DOT1:        
235A   CD F5 20               CALL   printdec   
235D                DOT2:        
235D   CD 2D 21               CALL   space   
2360   FD E9                  JP   (IY)   
2362                DROP_:       ; Discard the top member of the stack
2362   E1                     POP   HL   
2363   FD E9                  JP   (IY)   
2365                DUP_:        
2365   E1                     POP   HL   ; Duplicate the top member of the stack
2366   E5                     PUSH   HL   
2367   E5                     PUSH   HL   
2368   FD E9                  JP   (IY)   
236A                EXIT_:       
236A   03                     INC   BC   
236B   50 59                  LD   DE,BC   
236D   CD DF 24               CALL   rpop   ; Restore Instruction pointer
2370   44 4D                  LD   BC,HL   
2372   EB                     EX   DE,HL   
2373   E9                     JP   (HL)   
2374                FETCH_:      ; Fetch the value from the address placed on the top of the stack
2374   E1                     POP   HL   ; 10t
2375                FETCH1:      
2375   5E                     LD   E,(HL)   ; 7t
2376   23                     INC   HL   ; 6t
2377   56                     LD   D,(HL)   ; 7t
2378   D5                     PUSH   DE   ; 11t
2379   FD E9                  JP   (IY)   ; 8t
237B                             ; 49t
237B   CD 92 26     HEX_:     CALL   get_hex   
237E   18 60                  JR   less   ; piggyback for ending
2380                HEXP_:       ; print hexadecimal
2380   E1                     POP   HL   
2381   CD AE 26               CALL   printhex   
2384   18 D7                  JR   dot2   
2386   C3 D3 20     NOP_:     JP   NEXT   ; hardwire white space to always go to NEXT (important for arrays)
2389                NUM_:        
2389   C3 B2 24               JP   number   
238C                OVER_:       
238C   E1                     POP   HL   ; Duplicate 2nd element of the stack
238D   D1                     POP   DE   
238E   D5                     PUSH   DE   
238F   E5                     PUSH   HL   
2390   D5                     PUSH   DE   ; And push it to top of stack
2391   FD E9                  JP   (IY)   
2393   C9           QUIT_:    RET      ; exit interpreter
2394                RET_:        
2394   CD DF 24               CALL   rpop   ; Restore Instruction pointer
2397   44 4D                  LD   BC,HL   
2399   FD E9                  JP   (IY)   
239B                STORE_:      ; Store the value at the address placed on the top of the stack
239B   E1                     POP   HL   ; 10t
239C   D1                     POP   DE   ; 10t
239D   73                     LD   (HL),E   ; 7t
239E   23                     INC   HL   ; 6t
239F   72                     LD   (HL),D   ; 7t
23A0   FD E9                  JP   (IY)   ; 8t
23A2                             ; 48t
23A2                             ; $ swap                    ; a b -- b a Swap the top 2 elements of the stack
23A2                SWAP_:       
23A2   E1                     POP   HL   
23A3   E3                     EX   (SP),HL   
23A4   E5                     PUSH   HL   
23A5   FD E9                  JP   (IY)   
23A7                             ;  Left shift { is multply by 2		
23A7                SHL_:        
23A7   E1                     POP   HL   ; Duplicate the top member of the stack
23A8   29                     ADD   HL,HL   
23A9   E5                     PUSH   HL   ; shift left fallthrough into add_
23AA   FD E9                  JP   (IY)   ; 8t
23AC                             ;  Right shift } is a divide by 2		
23AC                             ; 
23AC                SHR_:        
23AC   E1                     POP   HL   ; Get the top member of the stack
23AD   CB 3C                  SRL   H   
23AF   CB 1D                  RR   L   
23B1   E5                     PUSH   HL   
23B2   FD E9                  JP   (IY)   ; 8t
23B4   21 00 00     NEG_:     LD   HL,0   ; NEGate the value on top of stack (2's complement)
23B7   D1                     POP   DE   ; 10t
23B8   18 02                  JR   SUB_2   ; use the SUBtract routine
23BA                SUB_:        ; Subtract the value 2nd on stack from top of stack
23BA   D1                     POP   DE   ; 10t
23BB   E1           SUB_1:    POP   HL   ; 10t  Entry point for INVert
23BC   A7           SUB_2:    AND   A   ;  4t  Entry point for NEGate
23BD   ED 52                  SBC   HL,DE   ; 15t
23BF   E5                     PUSH   HL   ; 11t
23C0   FD E9                  JP   (IY)   ; 8t
23C2                             ; 58t
23C2   E1           EQ_:      POP   HL   
23C3   D1                     POP   DE   
23C4   A7                     AND   A   ; reset the carry flag
23C5   ED 52                  SBC   HL,DE   ; only equality sets HL=0 here
23C7   28 16                  JR   Z,equal   
23C9   21 00 00               LD   HL,0   
23CC   18 12                  JR   less   ; HL = 1
23CE   D1           GT_:      POP   DE   
23CF   E1                     POP   HL   
23D0   18 02                  JR   cmp_   
23D2   E1           LT_:      POP   HL   
23D3   D1                     POP   DE   
23D4   A7           CMP_:     AND   A   ; reset the carry flag
23D5   ED 52                  SBC   HL,DE   ; only equality sets HL=0 here
23D7   28 07                  JR   Z,less   ; equality returns 0  KB 25/11/21
23D9   21 00 00               LD   HL,0   
23DC   FA E0 23               JP   M,less   
23DF   2C           EQUAL:    INC   L   ; HL = 1
23E0                LESS:        
23E0   E5                     PUSH   HL   
23E1   FD E9                  JP   (IY)   
23E3                VAR_:        
23E3   0A                     LD   A,(BC)   
23E4   D6 3F                  SUB   "a" - ((VARS - mintVars)/2)   
23E6   87                     ADD   A,A   
23E7   6F                     LD   L,A   
23E8   26 3B                  LD   H,msb(mintVars)   
23EA   E5                     PUSH   HL   
23EB   FD E9                  JP   (IY)   
23ED   18 15        STR_:     JR   str   
23EF   18 22        AGAIN_:   JR   again   
23F1   18 4E        MUL_:     JR   mul   
23F3   18 68        DIV_:     JR   div   
23F5                GETREF_:      
23F5                             ;*******************************************************************
23F5                             ; Page 5 primitive routines
23F5                             ;*******************************************************************
23F5                             ;falls through
23F5                GETREF:      
23F5   03                     INC   BC   
23F6   0A                     LD   A,(BC)   
23F7   D6 41                  SUB   "A"   
23F9   87                     ADD   A,A   
23FA   5F                     LD   E,A   
23FB   16 00                  LD   D,0   
23FD   21 78 3B               LD   HL,defs   
2400   19                     ADD   HL,DE   
2401   C3 75 23               JP   fetch1   
2404                             ; **************************************************************************
2404                             ; Print the string between the `backticks`
2404                STR:         
2404   03                     INC   BC   
2405                NEXTCHAR:      
2405   0A                     LD   A,(BC)   
2406   03                     INC   BC   
2407   FE 60                  CP   "`"   ; ` is the string terminator
2409   28 05                  JR   Z,stringend   
240B   CD 16 20               CALL   putchar   
240E   18 F5                  JR   nextchar   
2410                STRINGEND:      
2410   0B                     DEC   BC   
2411   FD E9                  JP   (IY)   
2413                AGAIN:       ;20
2413   21 2C 3C               LD   HL,vIFTEMode   
2416   AF                     XOR   A   
2417   B6                     OR   (HL)   
2418   20 25                  JR   NZ,again2   
241A   DD 5E 00               LD   E,(IX+0)   ; peek loop var
241D   DD 56 01               LD   D,(IX+1)   
2420   DD 6E 02               LD   L,(IX+2)   ; peek loop limit
2423   DD 66 03               LD   H,(IX+3)   
2426   B7                     OR   A   
2427   ED 52                  SBC   HL,DE   
2429   28 0F                  JR   Z,again1   
242B   13                     INC   DE   
242C   DD 73 00               LD   (IX+0),E   ; poke loop var
242F   DD 72 01               LD   (IX+1),D   
2432   DD 4E 04               LD   C,(IX+4)   ; peek loop address
2435   DD 46 05               LD   B,(IX+5)   
2438   FD E9                  JP   (IY)   
243A                AGAIN1:      
243A   11 06 00               LD   DE,6   ; drop loop frame
243D   DD 19                  ADD   IX,DE   
243F                AGAIN2:      
243F   FD E9                  JP   (IY)   
2441                             ; ********************************************************************
2441                             ; 16-bit multiply
2441                MUL:         ; 19
2441   D1                     POP   DE   ; get first value
2442   E1                     POP   HL   
2443   C5                     PUSH   BC   ; Preserve the IP
2444   44                     LD   B,H   ; BC = 2nd value
2445   4D                     LD   C,L   
2446   21 00 00               LD   HL,0   
2449   3E 10                  LD   A,16   
244B                MUL_LOOP_1:      
244B   29                     ADD   HL,HL   
244C   CB 13                  RL   E   
244E   CB 12                  RL   D   
2450   30 04                  JR   NC,$+6   
2452   09                     ADD   HL,BC   
2453   30 01                  JR   NC,$+3   
2455   13                     INC   DE   
2456   3D                     DEC   A   
2457   20 F2                  JR   NZ,Mul_Loop_1   
2459                             ; 
2459   C1                     POP   BC   ; Restore the IP
245A   E5                     PUSH   HL   ; Put the product on the stack - stack bug fixed 2/12/21
245B                             ; 
245B   FD E9                  JP   (IY)   
245D                             ; ********************************************************************
245D                             ; 16-bit division subroutine.
245D                             ; 
245D                             ; BC: divisor, DE: dividend, HL: remainder
245D                             ; *********************************************************************
245D                             ; This divides DE by BC, storing the result in DE, remainder in HL
245D                             ; *********************************************************************
245D                             ; 1382 cycles
245D                             ; 35 bytes (reduced from 48)
245D                             ; 
245D                DIV:         ; 24
245D   D1                     POP   DE   ; get first value
245E   E1                     POP   HL   ; get 2nd value
245F   C5                     PUSH   BC   ; Preserve the IP
2460   44                     LD   B,H   ; BC = 2nd value
2461   4D                     LD   C,L   
2462                             ; 
2462   21 00 00               LD   hl,0   ; Zero the remainder
2465   3E 10                  LD   a,16   ; Loop counter
2467                DIV_LOOP:      ;shift the bits from BC (numerator) into HL (accumulator)
2467   CB 21                  SLA   c   
2469   CB 10                  RL   b   
246B   ED 6A                  ADC   hl,hl   
246D   ED 52                  SBC   hl,de   ;Check if remainder >= denominator (HL>=DE)
246F   38 03                  JR   c,div_adjust   
2471   0C                     INC   c   
2472   18 01                  JR   div_done   
2474                DIV_ADJUST:      ; remainder is not >= denominator, so we have to add DE back to HL
2474   19                     ADD   hl,de   
2475                DIV_DONE:      
2475   3D                     DEC   a   
2476   20 EF                  JR   nz,div_loop   
2478   50                     LD   D,B   ; Result from BC to DE
2479   59                     LD   E,C   
247A                DIV_END:      
247A   C1                     POP   BC   ; Restore the IP
247B   D5                     PUSH   DE   ; Push Result
247C   E5                     PUSH   HL   ; Push remainder
247D   FD E9                  JP   (IY)   
247F                             ; *************************************
247F                             ; Loop Handling Code
247F                             ; *************************************
247F                             ; 
247F                BEGIN:       ;23                     ; Left parentesis begins a loop
247F   21 2C 3C               LD   HL,vIFTEMode   
2482   36 00                  LD   (HL),0   
2484   E1                     POP   HL   
2485   7D                     LD   A,L   ; zero?
2486   B4                     OR   H   
2487   28 1C                  JR   Z,begin1   
2489   2B                     DEC   HL   
248A   11 FA FF               LD   DE,-6   
248D   DD 19                  ADD   IX,DE   
248F   DD 36 00 00            LD   (IX+0),0   ; loop var
2493   DD 36 01 00            LD   (IX+1),0   
2497   DD 75 02               LD   (IX+2),L   ; loop limit
249A   DD 74 03               LD   (IX+3),H   
249D   DD 71 04               LD   (IX+4),C   ; loop address
24A0   DD 70 05               LD   (IX+5),B   
24A3   FD E9                  JP   (IY)   
24A5                BEGIN1:      
24A5   1E 01                  LD   E,1   
24A7                BEGIN2:      
24A7   03                     INC   BC   
24A8   0A                     LD   A,(BC)   
24A9   CD CD 26               CALL   nesting   
24AC   AF                     XOR   A   
24AD   B3                     OR   E   
24AE   20 F7                  JR   NZ,begin2   
24B0   FD E9                  JP   (IY)   
24B2                             ; ********************************************************************************
24B2                             ; Number Handling Routine - converts numeric ascii string to a 16-bit number in HL
24B2                             ; Read the first character.
24B2                             ;			
24B2                             ; Number characters ($30 to $39) are converted to digits by subtracting $30
24B2                             ; and then added into the L register. (HL forms a 16-bit accumulator)
24B2                             ; Fetch the next character, if it is a number, multiply contents of HL by 10
24B2                             ; and then add in the next digit. Repeat this until a non-number character is
24B2                             ; detected. Add in the final digit so that HL contains the converted number.
24B2                             ; Push HL onto the stack and proceed to the dispatch routine.
24B2                             ; ********************************************************************************
24B2                NUMBER:      ; 23
24B2   21 00 00               LD   HL,$0000   ; 10t Clear HL to accept the number
24B5   0A                     LD   A,(BC)   ; 7t  Get the character which is a numeral
24B6                NUMBER1:      ; corrected KB 24/11/21
24B6   D6 30                  SUB   $30   ; 7t    Form decimal digit
24B8   85                     ADD   A,L   ; 4t    Add into bottom of HL
24B9   6F                     LD   L,A   ; 4t
24BA   3E 00                  LD   A,00   ; 4t    Clear A
24BC   8C                     ADC   A,H   ; Add with carry H-reg
24BD   67                     LD   H,A   ; Put result in H-reg
24BE   03                     INC   BC   ; 6t    Increment IP
24BF   0A                     LD   A,(BC)   ; 7t    and get the next character
24C0   FE 30                  CP   $30   ; 7t    Less than $30
24C2   38 0C                  JR   C,endnum   ; 7/12t Not a number / end of number
24C4   FE 3A                  CP   $3A   ; 7t    Greater or equal to $3A
24C6   30 08                  JR   NC,endnum   ; 7/12t Not a number / end of number
24C8                TIMES10:      ; Multiply digit(s) in HL by 10
24C8   29                     ADD   HL,HL   ; 11t    2X
24C9   5D                     LD   E,L   ;  4t    LD DE,HL
24CA   54                     LD   D,H   ;  4t
24CB   29                     ADD   HL,HL   ; 11t    4X
24CC   29                     ADD   HL,HL   ; 11t    8X
24CD   19                     ADD   HL,DE   ; 11t    2X  + 8X  = 10X
24CE                             ; 52t cycles
24CE   18 E6                  JR   number1   
24D0                ENDNUM:      
24D0   E5                     PUSH   HL   ; 11t   Put the number on the stack
24D1   0B                     DEC   BC   
24D2   FD E9                  JP   (IY)   ; and process the next character
24D4                RPUSH:       
24D4   DD 2B                  DEC   IX   
24D6   DD 74 00               LD   (IX+0),H   
24D9   DD 2B                  DEC   IX   
24DB   DD 75 00               LD   (IX+0),L   
24DE   C9                     RET      
24DF                RPOP:        
24DF   DD 6E 00               LD   L,(IX+0)   
24E2   DD 23                  INC   IX   
24E4   DD 66 00               LD   H,(IX+0)   
24E7   DD 23                  INC   IX   
24E9   C9                     RET      
24EA                CRLF:        
24EA   3E 0D                  LD   A,"\r"   
24EC   CD 16 20               CALL   putchar   
24EF   3E 0A                  LD   A,"\n"   
24F1   C3 16 20               JP   putchar   
24F4                ALT1:        
24F4   03                     INC   BC   
24F5   0A                     LD   A,(BC)   
24F6   21 80 22               LD   HL,altCodes   
24F9   85                     ADD   A,L   
24FA   6F                     LD   L,A   
24FB   6E                     LD   L,(HL)   ; 7t    get low jump address
24FC   26 25                  LD   H,msb(page6)   ; Load H with the 5th page address
24FE   E9                     JP   (HL)   ; 4t    Jump to routine
24FF                             ; **************************************************************************
24FF                             ; Page 6 Alt primitives
24FF                             ; **************************************************************************
24FF                          ALIGN   $100   
2500                PAGE6:       
2500                CARRDEF_:      ; define a byte array
2500   3E 01                  LD   A,TRUE   
2502   C3 3F 26               JP   arrDef1   
2505                CFETCH_:      
2505   E1                     POP   HL   ; 10t
2506   16 00                  LD   D,0   ; 7t
2508   5E                     LD   E,(HL)   ; 7t
2509   D5                     PUSH   DE   ; 11t
250A                ANOP_:       
250A   FD E9                  JP   (IY)   ; 8t
250C                             ; 49t
250C                CHARCODE_:      
250C   03                     INC   BC   
250D   0A                     LD   A,(BC)   
250E   26 00                  LD   H,0   
2510   6F                     LD   L,A   
2511   E5                     PUSH   HL   
2512   FD E9                  JP   (IY)   
2514                COMMENT_:      
2514   03                     INC   BC   ; point to next char
2515   0A                     LD   A,(BC)   
2516   FE 0D                  CP   "\r"   ; terminate at newline
2518   20 FA                  JR   NZ,comment_   
251A   0B                     DEC   BC   
251B   FD E9                  JP   (IY)   
251D                CSTORE_:      
251D   E1                     POP   HL   ; 10t
251E   D1                     POP   DE   ; 10t
251F   73                     LD   (HL),E   ; 7t
2520   FD E9                  JP   (IY)   ; 8t
2522                             ; 48t
2522                DEPTH_:      
2522   21 00 00               LD   HL,0   
2525   39                     ADD   HL,SP   
2526   EB                     EX   DE,HL   
2527   21 00 39               LD   HL,DSTACK   
252A   B7                     OR   A   
252B   ED 52                  SBC   HL,DE   
252D   CB 3C                  SRL   H   
252F   CB 1D                  RR   L   
2531   E5                     PUSH   HL   
2532   FD E9                  JP   (IY)   
2534                EMIT_:       
2534   E1                     POP   HL   
2535   7D                     LD   A,L   
2536   CD 16 20               CALL   putchar   
2539   FD E9                  JP   (IY)   
253B                IFTE_:       
253B   21 2C 3C               LD   HL,vIFTEMode   
253E   36 01                  LD   (HL),TRUE   
2540   B7                     OR   A   ; invert condition
2541   ED 62                  SBC   HL,HL   
2543   D1                     POP   DE   
2544   ED 52                  SBC   HL,DE   
2546   23                     INC   HL   
2547   E5                     PUSH   HL   
2548   CA A5 24               JP   Z,begin1   
254B   FD E9                  JP   (IY)   
254D                             ; 
254D                EXEC_:       
254D   CD 52 25               CALL   exec1   
2550   FD E9                  JP   (IY)   
2552                EXEC1:       
2552   E1                     POP   HL   
2553   E3                     EX   (SP),HL   
2554   E9                     JP   (HL)   
2555                GO_:         
2555   60 69                  LD   HL,BC   
2557   CD D4 24               CALL   rpush   ; save Instruction Pointer
255A   C1                     POP   BC   
255B   0B                     DEC   BC   
255C   FD E9                  JP   (IY)   ; Execute code from User def
255E                USERVAR_:      
255E   0A                     LD   A,(BC)   
255F   D6 59                  SUB   "a" - ((userVars - mintVars) / 2)   
2561   87                     ADD   A,A   
2562   6F                     LD   L,A   
2563   26 3B                  LD   H,msb(mintVars)   
2565   E5                     PUSH   HL   
2566   FD E9                  JP   (IY)   ; Execute code from User def
2568                I_:          
2568   DD E5                  PUSH   IX   
256A   FD E9                  JP   (IY)   
256C                             ; \+    a b -- [b]+a            ; increment variable at b by a
256C                INCR_:       
256C   E1                     POP   HL   
256D   D1                     POP   DE   
256E   7B                     LD   A,E   
256F   86                     ADD   A,(HL)   
2570   77                     LD   (HL),A   
2571   23                     INC   HL   
2572   7A                     LD   A,D   
2573   8E                     ADC   A,(HL)   
2574   77                     LD   (HL),A   
2575   FD E9                  JP   (IY)   
2577                INPORT_:      
2577   E1                     POP   HL   
2578   4D                     LD   C,L   
2579   ED 68                  IN   L,(C)   
257B   26 00                  LD   H,0   
257D   E5                     PUSH   HL   
257E   FD E9                  JP   (IY)   
2580                J_:          
2580   DD E5                  PUSH   IX   
2582   E1                     POP   HL   
2583   11 06 00               LD   DE,6   
2586   19                     ADD   HL,DE   
2587   E5                     PUSH   HL   
2588   FD E9                  JP   (IY)   
258A                KEY_:        
258A   CD 12 20               CALL   getchar   
258D   6F                     LD   L,A   
258E   26 00                  LD   H,0   
2590   E5                     PUSH   HL   
2591   FD E9                  JP   (IY)   
2593                SYSCONST_:      
2593   0A                     LD   A,(BC)   
2594   D6 30                  SUB   "0"   ; Calc index
2596   87                     ADD   A,A   
2597   21 00 3B               LD   HL,sysConsts   
259A   6F                     LD   L,A   
259B   C3 75 23               JP   fetch1   
259E                LEAST_:      ; a b -- c
259E   D1                     POP   DE   
259F   E1                     POP   HL   
25A0   B7                     OR   A   
25A1   ED 52                  SBC   HL,DE   
25A3   3F                     CCF      
25A4   18 05                  JR   most1   
25A6                MOST_:       ; a b -- c
25A6   D1                     POP   DE   
25A7   E1                     POP   HL   
25A8   B7                     OR   A   
25A9   ED 52                  SBC   HL,DE   
25AB                MOST1:       
25AB   38 02                  JR   C,most2   
25AD   19                     ADD   HL,DE   
25AE   EB                     EX   DE,HL   
25AF                MOST2:       
25AF   D5                     PUSH   DE   
25B0   FD E9                  JP   (IY)   
25B2                NEWLN_:      
25B2   CD EA 24               CALL   crlf   
25B5   FD E9                  JP   (IY)   
25B7                OUTPORT_:      
25B7   E1                     POP   HL   
25B8   4D                     LD   C,L   
25B9   E1                     POP   HL   
25BA   ED 69                  OUT   (C),L   
25BC   FD E9                  JP   (IY)   
25BE                ROT_:        ; a b c -- b c a
25BE   D1                     POP   DE   ; a b                   de = c
25BF   E1                     POP   HL   ; a                     hl = b
25C0   E3                     EX   (SP),HL   ; b                     hl = a
25C1   D5                     PUSH   DE   ; b c
25C2   E5                     PUSH   HL   ; b c a
25C3   FD E9                  JP   (IY)   
25C5                SIGN_:       
25C5   E1                     POP   HL   
25C6   CB 7C                  BIT   7,H   
25C8   21 00 00               LD   HL,0   
25CB   28 01                  JR   Z,sign2   
25CD   23                     INC   HL   
25CE                SIGN2:       
25CE   E5                     PUSH   HL   
25CF   FD E9                  JP   (IY)   
25D1                WHILE_:      
25D1   E1                     POP   HL   
25D2   7D                     LD   A,L   ; zero?
25D3   B4                     OR   H   
25D4   28 02                  JR   Z,while1   
25D6   FD E9                  JP   (IY)   
25D8                WHILE1:      
25D8   11 06 00               LD   DE,6   ; drop loop frame
25DB   DD 19                  ADD   IX,DE   
25DD   C3 A5 24               JP   begin1   ; skip to end of loop
25E0                EDITDEF_:      
25E0   18 25                  JR   editDef   
25E2                PRINTSTK_:      
25E2                             ; **************************************************************************
25E2                             ; Page 6 primitive routines
25E2                             ; **************************************************************************
25E2                             ; falls through
25E2                PRINTSTK:      
25E2   CD EC 20               CALL   ENTER   
25E5   5C 30 32 2D 5C 44 31 2D 5C 78 21 5C 78 40 5C 5F 30 3D 28 5C 78 40 28 22 40 2E 32 2D 29 29 27 00 DB   "\\02-\\D1-\\x!\\x@\\_0=(\\x@(",$22,"@.2-))'",0   
2605   FD E9                  JP   (IY)   
2607                             ; **************************************************************************
2607                             ; copy definition to text input buffer
2607                             ; update TIBPtr
2607                             ; **************************************************************************
2607                EDITDEF:      ; lookup up def based on number
2607   3E 41                  LD   A,"A"   
2609   D1                     POP   DE   
260A   83                     ADD   A,E   
260B   08                     EX   AF,AF'   
260C   21 78 3B               LD   HL,defs   
260F   19                     ADD   HL,DE   
2610   19                     ADD   HL,DE   
2611   5E                     LD   E,(HL)   
2612   23                     INC   HL   
2613   56                     LD   D,(HL)   
2614   EB                     EX   DE,HL   
2615   7E                     LD   A,(HL)   
2616   FE 3B                  CP   ";"   
2618   11 00 3A               LD   DE,TIB   
261B   28 14                  JR   Z,editDef3   
261D   3E 3A                  LD   A,":"   
261F   CD 32 21               CALL   writeChar   
2622   08                     EX   AF,AF'   
2623   CD 32 21               CALL   writeChar   
2626   18 01                  JR   editDef2   
2628                EDITDEF1:      
2628   23                     INC   HL   
2629                EDITDEF2:      
2629   7E                     LD   A,(HL)   
262A   CD 32 21               CALL   writeChar   
262D   FE 3B                  CP   ";"   
262F   20 F7                  JR   NZ,editDef1   
2631                EDITDEF3:      
2631   21 00 3A               LD   HL,TIB   
2634   EB                     EX   DE,HL   
2635   B7                     OR   A   
2636   ED 52                  SBC   HL,DE   
2638   22 14 3B               LD   (vTIBPtr),HL   
263B   FD E9                  JP   (IY)   
263D                             ;*******************************************************************
263D                             ; Page 5 primitive routines continued
263D                             ;*******************************************************************
263D                             ; define a word array
263D                ARRDEF:      
263D   3E 00                  LD   A,FALSE   
263F                ARRDEF1:      
263F   FD 21 19 21            LD   IY,compNEXT   
2643   32 2E 3C               LD   (vByteMode),A   
2646   2A 1E 3B               LD   HL,(vHeapPtr)   ; HL = heap ptr
2649   CD D4 24               CALL   rpush   ; save start of array \[  \]
264C   C3 D3 20               JP   NEXT   ; hardwired to NEXT
264F                             ; end a word array
264F                ARREND:      
264F   CD DF 24               CALL   rpop   ; DE = start of array
2652   E5                     PUSH   HL   
2653   EB                     EX   DE,HL   
2654   2A 1E 3B               LD   HL,(vHeapPtr)   ; HL = heap ptr
2657   B7                     OR   A   
2658   ED 52                  SBC   HL,DE   ; bytes on heap
265A   3A 2E 3C               LD   A,(vByteMode)   
265D   B7                     OR   A   
265E   20 04                  JR   NZ,arrEnd2   
2660   CB 3C                  SRL   H   ; BC = m words
2662   CB 1D                  RR   L   
2664                ARREND2:      
2664   E5                     PUSH   HL   
2665   FD 21 D3 20            LD   IY,NEXT   
2669   FD E9                  JP   (IY)   ; hardwired to NEXT
266B                             ; **************************************************************************
266B                             ; def is used to create a colon definition
266B                             ; When a colon is detected, the next character (usually uppercase alpha)
266B                             ; is looked up in the vector table to get its associated code field address
266B                             ; This CFA is updated to point to the character after uppercase alpha
266B                             ; The remainder of the characters are then skipped until after a semicolon
266B                             ; is found.
266B                             ; ***************************************************************************
266B                DEF:         ; Create a colon definition
266B   E5                     PUSH   HL   ; Save HL
266C   21 78 3B               LD   HL,DEFS   ; Start address of jump table
266F   03                     INC   BC   
2670   0A                     LD   A,(BC)   ; Get the next character
2671   03                     INC   BC   
2672   D6 05                  SUB   "A" - ((DEFS - mintVars)/2)   
2674   87                     ADD   A,A   
2675   6F                     LD   L,A   
2676   26 3B                  LD   H,msb(mintVars)   
2678   ED 5B 1E 3B            LD   DE,(vHeapPtr)   ; start of defintion
267C   73                     LD   (HL),E   ; Save low byte of address in CFA
267D   23                     INC   HL   
267E   72                     LD   (HL),D   ; Save high byte of address in CFA+1
267F   E1                     POP   HL   ; Restore HL
2680                NEXTBYTE:      ; Skip to end of definition
2680   0A                     LD   A,(BC)   ; Get the next character
2681   03                     INC   BC   ; Point to next character
2682   12                     LD   (DE),A   
2683   13                     INC   DE   
2684   FE 3B                  CP   ";"   ; Is it a semicolon
2686   CA 8B 26               JP   z,end_def   ; end the definition
2689   18 F5                  JR   nextbyte   ; get the next element
268B                END_DEF:      
268B   ED 53 1E 3B            LD   (vHeapPtr),DE   ; bump heap ptr to after definiton
268F   0B                     DEC   BC   
2690   FD E9                  JP   (IY)   
2692                             ; ***************************************************************************
2692                GET_HEX:      
2692   21 00 00               LD   HL,$0000   ; 10t Clear HL to accept the number
2695   03                     INC   BC   
2696   0A                     LD   A,(BC)   ; 7t  Get the character which is a numeral
2697                GET_HEX1:      
2697   CB 77                  BIT   6,A   ; 7t    is it uppercase alpha?
2699   28 02                  JR   Z,ASCHX1   ; no a decimal
269B   D6 07                  SUB   7   ; sub 7  to make $A - $F
269D                ASCHX1:      
269D   D6 30                  SUB   $30   ; 7t    Form decimal digit
269F   85                     ADD   A,L   ; 4t    Add into bottom of HL
26A0   6F                     LD   L,A   ; 4t
26A1   03                     INC   BC   ; 6t    Increment IP
26A2   0A                     LD   A,(BC)   ; 7t    and get the next character
26A3   FE 20                  CP   $20   ; 7t    is a terminating space?
26A5   28 06                  JR   Z,endhex   ; 7/12t Not a number / end of number
26A7                TIMES16:      ; Multiply digit(s) in HL by 16
26A7   29                     ADD   HL,HL   ; 11t    2X
26A8   29                     ADD   HL,HL   ; 11t    4X
26A9   29                     ADD   HL,HL   ; 11t    8X
26AA   29                     ADD   HL,HL   ; 11t   16X
26AB   18 EA                  JR   get_hex1   
26AD   C9           ENDHEX:   RET      
26AE                PRINTHEX:      
26AE                             ; Display HL as a 16-bit number in hex.
26AE   C5                     PUSH   BC   ; preserve the IP
26AF   7C                     LD   A,H   
26B0   CD B9 26               CALL   Print_Hex8   
26B3   7D                     LD   A,L   
26B4   CD B9 26               CALL   Print_Hex8   
26B7   C1                     POP   BC   
26B8   C9                     RET      
26B9                             ; Print an 8-bit HEX number  - shortened KB 25/11/21
26B9                             ; A: Number to print
26B9                             ; 
26B9                PRINT_HEX8:      
26B9   4F                     LD   C,A   
26BA   1F                     RRA      
26BB   1F                     RRA      
26BC   1F                     RRA      
26BD   1F                     RRA      
26BE   CD C2 26               CALL   conv   
26C1   79                     LD   A,C   
26C2                CONV:        
26C2   E6 0F                  AND   0x0F   
26C4   C6 90                  ADD   A,0x90   
26C6   27                     DAA      
26C7   CE 40                  ADC   A,0x40   
26C9   27                     DAA      
26CA   C3 16 20               JP   putchar   
26CD                             ; **************************************************************************
26CD                             ; calculate nesting value
26CD                             ; A is char to be tested,
26CD                             ; E is the nesting value (initially 0)
26CD                             ; E is increased by ( and [
26CD                             ; E is decreased by ) and ]
26CD                             ; E has its bit 7 toggled by `
26CD                             ; limited to 127 levels
26CD                             ; **************************************************************************
26CD                NESTING:      
26CD   FE 60                  CP   "`"   
26CF   20 0A                  JR   NZ,nesting1   
26D1   CB 7B                  BIT   7,E   
26D3   28 03                  JR   Z,nesting1a   
26D5   CB BB                  RES   7,E   
26D7   C9                     RET      
26D8                NESTING1A:      
26D8   CB FB                  SET   7,E   
26DA   C9                     RET      
26DB                NESTING1:      
26DB   CB 7B                  BIT   7,E   
26DD   C0                     RET   NZ   
26DE   FE 3A                  CP   ":"   
26E0   28 08                  JR   Z,nesting2   
26E2   FE 5B                  CP   "["   
26E4   28 04                  JR   Z,nesting2   
26E6   FE 28                  CP   "("   
26E8   20 02                  JR   NZ,nesting3   
26EA                NESTING2:      
26EA   1C                     INC   E   
26EB   C9                     RET      
26EC                NESTING3:      
26EC   FE 3B                  CP   ";"   
26EE   28 07                  JR   Z,nesting4   
26F0   FE 5D                  CP   "]"   
26F2   28 03                  JR   Z,nesting4   
26F4   FE 29                  CP   ")"   
26F6   C0                     RET   NZ   
26F7                NESTING4:      
26F7   1D                     DEC   E   
26F8   C9                     RET      
3800                          .ORG   RAMSTART   
3800                          DS   DSIZE   
3900                STACK:       
3900                DSTACK:      
3900                          DS   RSIZE   
3A00                RSTACK:      
3A00                TIB:         
3A00                          DS   TIBSIZE   
3B00                          ALIGN   $100   
3B00                MINTVARS:      
3B00                             ; ****************************************************************
3B00                             ; System constants
3B00                             ; ****************************************************************
3B00                SYSCONSTS:      
3B00   00 00        CS0:      DW   0   ; 0
3B02   00 00        CTIB:     DW   0   ; 1
3B04   00 00        CDEFS:    DW   0   ; 2
3B06   00 00        CVARS:    DW   0   ; 3
3B08   00 00        COPCODES:   DW   0   ; 4
3B0A   00 00        CMACROS:   DW   0   ; 5
3B0C   00 00        CUSERVARS:   DW   0   ; 6
3B0E   00 00                  DW   0   ; 7
3B10                             ; ****************************************************************
3B10                             ; USER variables
3B10                             ; ****************************************************************
3B10                USERVARS:      
3B10   00 00        VALT:     DW   0   ; a
3B12   00 00        VBASE16:   DW   0   ; b
3B14   00 00        VTIBPTR:   DW   0   ; c
3B16   00 00                  DW   0   ; d
3B18   00 00                  DW   0   ; e
3B1A   00 00                  DW   0   ; f
3B1C   00 00                  DW   0   ; g
3B1E   00 00        VHEAPPTR:   DW   0   ; h
3B20   00 00                  DW   0   ; i
3B22   00 00                  DW   0   ; j
3B24   00 00                  DW   0   ; k
3B26   00 00                  DW   0   ; l
3B28   00 00                  DW   0   ; m
3B2A   00 00                  DW   0   ; n
3B2C   00 00                  DW   0   ; o
3B2E   00 00                  DW   0   ; p
3B30   00 00                  DW   0   ; q
3B32   00 00                  DW   0   ; r
3B34   00 00                  DW   0   ; s
3B36   00 00                  DW   0   ; t
3B38   00 00                  DW   0   ; u
3B3A   00 00                  DW   0   ; v
3B3C   00 00                  DW   0   ; w
3B3E   00 00                  DW   0   ; x
3B40   00 00                  DW   0   ; y
3B42   00 00                  DW   0   ; z
3B44                             ; ****************************************************************
3B44                             ; VARS Table - holds 26 16-bit user variables
3B44                             ; ****************************************************************
3B44                VARS:     DS   26 * 2   
3B78                             ; ****************************************************************
3B78                             ; DEFS Table - holds 26 addresses of user routines
3B78                             ; ****************************************************************
3B78                DEFS:     DS   26 * 2   
3BAC                BUF:      DS   $80   
3C2C   00 00        VIFTEMODE:   DW   0   ; 
3C2E   00 00        VBYTEMODE:   DW   0   ; 
3C30   00 00        RST08:    DW   0   ; 
3C32   00 00        RST10:    DW   0   ; 
3C34   00 00        RST18:    DW   0   ; 
3C36   00 00        RST20:    DW   0   ; 
3C38   00 00        RST28:    DW   0   ; 
3C3A   00 00        RST30:    DW   0   ; 
3C3C   00 00        BAUD:     DW   0   ; 
3C3E   00 00        INTVEC:   DW   0   ; 
3C40   00 00        NMIVEC:   DW   0   ; 
3C42   00 00        GETCVEC:   DW   0   ; 
3C44   00 00        PUTCVEC:   DW   0   ; 
3C46   00 00        TBPTR:    DW   0   ; reserved for tests
3C48                          ALIGN   $40   
3C80                HEAP:        


PGMSTART:           2000 DEFINED AT LINE 3
                    > USED AT LINE 17
RAMSTART:           3800 DEFINED AT LINE 4
                    > USED AT LINE 1 IN ram.asm
KEYBUF:             0000 DEFINED AT LINE 8
SCAN:               0001 DEFINED AT LINE 9
DISPLY:             0002 DEFINED AT LINE 10
PORT3:              0003 DEFINED AT LINE 11
PORT4:              0004 DEFINED AT LINE 12
PORT5:              0005 DEFINED AT LINE 13
PORT6:              0006 DEFINED AT LINE 14
PORT7:              0007 DEFINED AT LINE 15
GETCHAR:            2012 DEFINED AT LINE 28
                    > USED AT LINE 224 IN MINT.asm
                    > USED AT LINE 1249 IN MINT.asm
PUTCHAR:            2016 DEFINED AT LINE 32
                    > USED AT LINE 239 IN MINT.asm
                    > USED AT LINE 332 IN MINT.asm
                    > USED AT LINE 351 IN MINT.asm
                    > USED AT LINE 356 IN MINT.asm
                    > USED AT LINE 898 IN MINT.asm
                    > USED AT LINE 1106 IN MINT.asm
                    > USED AT LINE 1108 IN MINT.asm
                    > USED AT LINE 1176 IN MINT.asm
                    > USED AT LINE 1507 IN MINT.asm
CONTROL:            0080 DEFINED AT LINE 4 IN Char-6850.asm
                    > USED AT LINE 56 IN Char-6850.asm
                    > USED AT LINE 59 IN Char-6850.asm
STATUS:             0080 DEFINED AT LINE 5 IN Char-6850.asm
                    > USED AT LINE 67 IN Char-6850.asm
                    > USED AT LINE 77 IN Char-6850.asm
TDR:                0081 DEFINED AT LINE 6 IN Char-6850.asm
                    > USED AT LINE 71 IN Char-6850.asm
RDR:                0081 DEFINED AT LINE 7 IN Char-6850.asm
                    > USED AT LINE 80 IN Char-6850.asm
MRESET:             0003 DEFINED AT LINE 14 IN Char-6850.asm
                    > USED AT LINE 55 IN Char-6850.asm
CLKDIV_0:           0000 DEFINED AT LINE 15 IN Char-6850.asm
CLKDIV_16:          0001 DEFINED AT LINE 16 IN Char-6850.asm
CLKDIV_64:          0002 DEFINED AT LINE 17 IN Char-6850.asm
                    > USED AT LINE 58 IN Char-6850.asm
F7E2:               0000 DEFINED AT LINE 21 IN Char-6850.asm
F7O2:               0004 DEFINED AT LINE 22 IN Char-6850.asm
F7E1:               0008 DEFINED AT LINE 23 IN Char-6850.asm
F7O1:               000C DEFINED AT LINE 24 IN Char-6850.asm
F8N2:               0010 DEFINED AT LINE 25 IN Char-6850.asm
                    > USED AT LINE 58 IN Char-6850.asm
F8N1:               0014 DEFINED AT LINE 26 IN Char-6850.asm
F8E1:               0018 DEFINED AT LINE 27 IN Char-6850.asm
F8O1:               001C DEFINED AT LINE 28 IN Char-6850.asm
RTSLID:             0000 DEFINED AT LINE 32 IN Char-6850.asm
                    > USED AT LINE 58 IN Char-6850.asm
RTSLIE:             0020 DEFINED AT LINE 33 IN Char-6850.asm
RTSHID:             0040 DEFINED AT LINE 34 IN Char-6850.asm
RTSLIDB:            0060 DEFINED AT LINE 35 IN Char-6850.asm
RIE:                0080 DEFINED AT LINE 39 IN Char-6850.asm
RDRF:               0000 DEFINED AT LINE 43 IN Char-6850.asm
TDRE:               0001 DEFINED AT LINE 44 IN Char-6850.asm
DCD:                0002 DEFINED AT LINE 45 IN Char-6850.asm
CTS:                0003 DEFINED AT LINE 46 IN Char-6850.asm
FE:                 0004 DEFINED AT LINE 47 IN Char-6850.asm
OVRN:               0005 DEFINED AT LINE 48 IN Char-6850.asm
PE:                 0006 DEFINED AT LINE 49 IN Char-6850.asm
IRQ:                0007 DEFINED AT LINE 50 IN Char-6850.asm
INITIALISESERIAL:   201C DEFINED AT LINE 54 IN Char-6850.asm
                    > USED AT LINE 24
TXCHAR:             2025 DEFINED AT LINE 64 IN Char-6850.asm
                    > USED AT LINE 21
TXCHAR1:            2026 DEFINED AT LINE 66 IN Char-6850.asm
                    > USED AT LINE 69 IN Char-6850.asm
RXCHAR:             2030 DEFINED AT LINE 76 IN Char-6850.asm
                    > USED AT LINE 19
                    > USED AT LINE 79 IN Char-6850.asm
DSIZE:              0100 DEFINED AT LINE 151 IN MINT.asm
                    > USED AT LINE 3 IN ram.asm
RSIZE:              0100 DEFINED AT LINE 152 IN MINT.asm
                    > USED AT LINE 7 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 153 IN MINT.asm
                    > USED AT LINE 11 IN ram.asm
TRUE:               0001 DEFINED AT LINE 154 IN MINT.asm
                    > USED AT LINE 1127 IN MINT.asm
                    > USED AT LINE 1181 IN MINT.asm
FALSE:              0000 DEFINED AT LINE 155 IN MINT.asm
                    > USED AT LINE 497 IN MINT.asm
                    > USED AT LINE 1382 IN MINT.asm
START:              2039 DEFINED AT LINE 166 IN MINT.asm
                    > USED AT LINE 26
MINT:               2039 DEFINED AT LINE 167 IN MINT.asm
INITIALIZE:         2053 DEFINED AT LINE 174 IN MINT.asm
                    > USED AT LINE 169 IN MINT.asm
INIT1:              206B DEFINED AT LINE 183 IN MINT.asm
                    > USED AT LINE 188 IN MINT.asm
INTERPRET:          2074 DEFINED AT LINE 191 IN MINT.asm
                    > USED AT LINE 172 IN MINT.asm
                    > USED AT LINE 291 IN MINT.asm
INTERPRET1:         207E DEFINED AT LINE 195 IN MINT.asm
INTERPRET2:         2085 DEFINED AT LINE 199 IN MINT.asm
                    > USED AT LINE 369 IN MINT.asm
INTERPRET3:         208D DEFINED AT LINE 206 IN MINT.asm
                    > USED AT LINE 215 IN MINT.asm
INTERPRET4:         2093 DEFINED AT LINE 212 IN MINT.asm
                    > USED AT LINE 204 IN MINT.asm
WAITCHAR:           2098 DEFINED AT LINE 223 IN MINT.asm
                    > USED AT LINE 241 IN MINT.asm
                    > USED AT LINE 251 IN MINT.asm
WAITCHAR1:          20AC DEFINED AT LINE 234 IN MINT.asm
                    > USED AT LINE 226 IN MINT.asm
WAITCHAR3:          20BA DEFINED AT LINE 243 IN MINT.asm
                    > USED AT LINE 230 IN MINT.asm
WAITCHAR4:          20CB DEFINED AT LINE 255 IN MINT.asm
                    > USED AT LINE 228 IN MINT.asm
NEXT:               20D3 DEFINED AT LINE 283 IN MINT.asm
                    > USED AT LINE 176 IN MINT.asm
                    > USED AT LINE 293 IN MINT.asm
                    > USED AT LINE 347 IN MINT.asm
                    > USED AT LINE 767 IN MINT.asm
                    > USED AT LINE 1388 IN MINT.asm
                    > USED AT LINE 1405 IN MINT.asm
DISPATCH:           20D5 DEFINED AT LINE 287 IN MINT.asm
ENTER:              20EC DEFINED AT LINE 301 IN MINT.asm
                    > USED AT LINE 170 IN MINT.asm
                    > USED AT LINE 192 IN MINT.asm
                    > USED AT LINE 366 IN MINT.asm
                    > USED AT LINE 1332 IN MINT.asm
PRINTDEC:           20F5 DEFINED AT LINE 308 IN MINT.asm
                    > USED AT LINE 727 IN MINT.asm
DISPHL:             20F5 DEFINED AT LINE 315 IN MINT.asm
NUM1:               210E DEFINED AT LINE 325 IN MINT.asm
                    > USED AT LINE 317 IN MINT.asm
                    > USED AT LINE 319 IN MINT.asm
                    > USED AT LINE 321 IN MINT.asm
                    > USED AT LINE 323 IN MINT.asm
NUM2:               2110 DEFINED AT LINE 327 IN MINT.asm
                    > USED AT LINE 330 IN MINT.asm
COMPNEXT:           2119 DEFINED AT LINE 335 IN MINT.asm
                    > USED AT LINE 1384 IN MINT.asm
COMPNEXT1:          2127 DEFINED AT LINE 345 IN MINT.asm
                    > USED AT LINE 342 IN MINT.asm
SPACE:              212D DEFINED AT LINE 349 IN MINT.asm
                    > USED AT LINE 729 IN MINT.asm
WRITECHAR:          2132 DEFINED AT LINE 353 IN MINT.asm
                    > USED AT LINE 1357 IN MINT.asm
                    > USED AT LINE 1359 IN MINT.asm
                    > USED AT LINE 1365 IN MINT.asm
MACRO:              2137 DEFINED AT LINE 358 IN MINT.asm
                    > USED AT LINE 232 IN MINT.asm
MACROS:             2151 DEFINED AT LINE 375 IN MINT.asm
                    > USED AT LINE 491 IN MINT.asm
EMPTY_:             2151 DEFINED AT LINE 1 IN MINT.asm
BACKSP_:            2153 DEFINED AT LINE 4 IN MINT.asm
EDIT_:              216D DEFINED AT LINE 7 IN MINT.asm
LIST_:              2180 DEFINED AT LINE 10 IN MINT.asm
PRINTSTACK_:        219C DEFINED AT LINE 13 IN MINT.asm
TOGGLEBASE_:        21AD DEFINED AT LINE 16 IN MINT.asm
OPCODES:            2200 DEFINED AT LINE 384 IN MINT.asm
                    > USED AT LINE 294 IN MINT.asm
                    > USED AT LINE 490 IN MINT.asm
ISYSCONSTS:         2260 DEFINED AT LINE 485 IN MINT.asm
                    > USED AT LINE 177 IN MINT.asm
IUSERVARS:          2270 DEFINED AT LINE 495 IN MINT.asm
CTRLCODES:          2280 DEFINED AT LINE 509 IN MINT.asm
                    > USED AT LINE 360 IN MINT.asm
ALTCODES:           2280 DEFINED AT LINE 510 IN MINT.asm
                    > USED AT LINE 1113 IN MINT.asm
PAGE4:              2300 DEFINED AT LINE 645 IN MINT.asm
ALT_:               2300 DEFINED AT LINE 647 IN MINT.asm
AND_:               2304 DEFINED AT LINE 651 IN MINT.asm
AND1:               230B DEFINED AT LINE 659 IN MINT.asm
                    > USED AT LINE 673 IN MINT.asm
                    > USED AT LINE 684 IN MINT.asm
OR_:                230F DEFINED AT LINE 665 IN MINT.asm
XOR_:               2318 DEFINED AT LINE 675 IN MINT.asm
XOR1:               2319 DEFINED AT LINE 677 IN MINT.asm
                    > USED AT LINE 688 IN MINT.asm
INV_:               2321 DEFINED AT LINE 686 IN MINT.asm
ADD_:               2326 DEFINED AT LINE 690 IN MINT.asm
ARRDEF_:            232C DEFINED AT LINE 698 IN MINT.asm
ARREND_:            232F DEFINED AT LINE 699 IN MINT.asm
BEGIN_:             2332 DEFINED AT LINE 700 IN MINT.asm
CALL_:              2335 DEFINED AT LINE 701 IN MINT.asm
DEF_:               234B DEFINED AT LINE 718 IN MINT.asm
DOT_:               234E DEFINED AT LINE 719 IN MINT.asm
DOT1:               235A DEFINED AT LINE 726 IN MINT.asm
                    > USED AT LINE 723 IN MINT.asm
DOT2:               235D DEFINED AT LINE 728 IN MINT.asm
                    > USED AT LINE 725 IN MINT.asm
                    > USED AT LINE 765 IN MINT.asm
DROP_:              2362 DEFINED AT LINE 732 IN MINT.asm
DUP_:               2365 DEFINED AT LINE 736 IN MINT.asm
EXIT_:              236A DEFINED AT LINE 742 IN MINT.asm
                    > USED AT LINE 289 IN MINT.asm
FETCH_:             2374 DEFINED AT LINE 750 IN MINT.asm
FETCH1:             2375 DEFINED AT LINE 752 IN MINT.asm
                    > USED AT LINE 885 IN MINT.asm
                    > USED AT LINE 1261 IN MINT.asm
HEX_:               237B DEFINED AT LINE 759 IN MINT.asm
HEXP_:              2380 DEFINED AT LINE 762 IN MINT.asm
NOP_:               2386 DEFINED AT LINE 767 IN MINT.asm
NUM_:               2389 DEFINED AT LINE 769 IN MINT.asm
OVER_:              238C DEFINED AT LINE 772 IN MINT.asm
QUIT_:              2393 DEFINED AT LINE 780 IN MINT.asm
RET_:               2394 DEFINED AT LINE 782 IN MINT.asm
STORE_:             239B DEFINED AT LINE 787 IN MINT.asm
SWAP_:              23A2 DEFINED AT LINE 796 IN MINT.asm
SHL_:               23A7 DEFINED AT LINE 803 IN MINT.asm
SHR_:               23AC DEFINED AT LINE 811 IN MINT.asm
NEG_:               23B4 DEFINED AT LINE 818 IN MINT.asm
SUB_:               23BA DEFINED AT LINE 822 IN MINT.asm
SUB_1:              23BB DEFINED AT LINE 825 IN MINT.asm
SUB_2:              23BC DEFINED AT LINE 826 IN MINT.asm
                    > USED AT LINE 820 IN MINT.asm
EQ_:                23C2 DEFINED AT LINE 831 IN MINT.asm
GT_:                23CE DEFINED AT LINE 840 IN MINT.asm
LT_:                23D2 DEFINED AT LINE 844 IN MINT.asm
CMP_:               23D4 DEFINED AT LINE 846 IN MINT.asm
                    > USED AT LINE 842 IN MINT.asm
EQUAL:              23DF DEFINED AT LINE 851 IN MINT.asm
                    > USED AT LINE 835 IN MINT.asm
LESS:               23E0 DEFINED AT LINE 852 IN MINT.asm
                    > USED AT LINE 760 IN MINT.asm
                    > USED AT LINE 837 IN MINT.asm
                    > USED AT LINE 848 IN MINT.asm
                    > USED AT LINE 850 IN MINT.asm
VAR_:               23E3 DEFINED AT LINE 856 IN MINT.asm
STR_:               23ED DEFINED AT LINE 867 IN MINT.asm
AGAIN_:             23EF DEFINED AT LINE 868 IN MINT.asm
MUL_:               23F1 DEFINED AT LINE 869 IN MINT.asm
DIV_:               23F3 DEFINED AT LINE 870 IN MINT.asm
GETREF_:            23F5 DEFINED AT LINE 871 IN MINT.asm
GETREF:             23F5 DEFINED AT LINE 876 IN MINT.asm
STR:                2404 DEFINED AT LINE 890 IN MINT.asm
                    > USED AT LINE 867 IN MINT.asm
NEXTCHAR:           2405 DEFINED AT LINE 893 IN MINT.asm
                    > USED AT LINE 899 IN MINT.asm
STRINGEND:          2410 DEFINED AT LINE 901 IN MINT.asm
                    > USED AT LINE 897 IN MINT.asm
AGAIN:              2413 DEFINED AT LINE 905 IN MINT.asm
                    > USED AT LINE 868 IN MINT.asm
AGAIN1:             243A DEFINED AT LINE 923 IN MINT.asm
                    > USED AT LINE 916 IN MINT.asm
AGAIN2:             243F DEFINED AT LINE 926 IN MINT.asm
                    > USED AT LINE 909 IN MINT.asm
MUL:                2441 DEFINED AT LINE 931 IN MINT.asm
                    > USED AT LINE 869 IN MINT.asm
MUL_LOOP_1:         244B DEFINED AT LINE 940 IN MINT.asm
                    > USED AT LINE 949 IN MINT.asm
DIV:                245D DEFINED AT LINE 969 IN MINT.asm
                    > USED AT LINE 870 IN MINT.asm
DIV_LOOP:           2467 DEFINED AT LINE 979 IN MINT.asm
                    > USED AT LINE 994 IN MINT.asm
DIV_ADJUST:         2474 DEFINED AT LINE 989 IN MINT.asm
                    > USED AT LINE 985 IN MINT.asm
DIV_DONE:           2475 DEFINED AT LINE 992 IN MINT.asm
                    > USED AT LINE 987 IN MINT.asm
DIV_END:            247A DEFINED AT LINE 999 IN MINT.asm
BEGIN:              247F DEFINED AT LINE 1011 IN MINT.asm
                    > USED AT LINE 700 IN MINT.asm
BEGIN1:             24A5 DEFINED AT LINE 1031 IN MINT.asm
                    > USED AT LINE 1018 IN MINT.asm
                    > USED AT LINE 1188 IN MINT.asm
                    > USED AT LINE 1322 IN MINT.asm
BEGIN2:             24A7 DEFINED AT LINE 1033 IN MINT.asm
                    > USED AT LINE 1039 IN MINT.asm
NUMBER:             24B2 DEFINED AT LINE 1054 IN MINT.asm
                    > USED AT LINE 770 IN MINT.asm
NUMBER1:            24B6 DEFINED AT LINE 1058 IN MINT.asm
                    > USED AT LINE 1083 IN MINT.asm
TIMES10:            24C8 DEFINED AT LINE 1074 IN MINT.asm
ENDNUM:             24D0 DEFINED AT LINE 1085 IN MINT.asm
                    > USED AT LINE 1070 IN MINT.asm
                    > USED AT LINE 1072 IN MINT.asm
RPUSH:              24D4 DEFINED AT LINE 1090 IN MINT.asm
                    > USED AT LINE 303 IN MINT.asm
                    > USED AT LINE 703 IN MINT.asm
                    > USED AT LINE 1201 IN MINT.asm
                    > USED AT LINE 1387 IN MINT.asm
RPOP:               24DF DEFINED AT LINE 1097 IN MINT.asm
                    > USED AT LINE 745 IN MINT.asm
                    > USED AT LINE 783 IN MINT.asm
                    > USED AT LINE 1392 IN MINT.asm
CRLF:               24EA DEFINED AT LINE 1104 IN MINT.asm
                    > USED AT LINE 248 IN MINT.asm
                    > USED AT LINE 1285 IN MINT.asm
ALT1:               24F4 DEFINED AT LINE 1110 IN MINT.asm
                    > USED AT LINE 496 IN MINT.asm
PAGE6:              2500 DEFINED AT LINE 1124 IN MINT.asm
CARRDEF_:           2500 DEFINED AT LINE 1126 IN MINT.asm
CFETCH_:            2505 DEFINED AT LINE 1130 IN MINT.asm
ANOP_:              250A DEFINED AT LINE 1135 IN MINT.asm
CHARCODE_:          250C DEFINED AT LINE 1138 IN MINT.asm
COMMENT_:           2514 DEFINED AT LINE 1146 IN MINT.asm
                    > USED AT LINE 1150 IN MINT.asm
CSTORE_:            251D DEFINED AT LINE 1154 IN MINT.asm
DEPTH_:             2522 DEFINED AT LINE 1161 IN MINT.asm
EMIT_:              2534 DEFINED AT LINE 1173 IN MINT.asm
IFTE_:              253B DEFINED AT LINE 1179 IN MINT.asm
EXEC_:              254D DEFINED AT LINE 1191 IN MINT.asm
EXEC1:              2552 DEFINED AT LINE 1194 IN MINT.asm
                    > USED AT LINE 1192 IN MINT.asm
GO_:                2555 DEFINED AT LINE 1199 IN MINT.asm
USERVAR_:           255E DEFINED AT LINE 1206 IN MINT.asm
I_:                 2568 DEFINED AT LINE 1215 IN MINT.asm
INCR_:              256C DEFINED AT LINE 1220 IN MINT.asm
INPORT_:            2577 DEFINED AT LINE 1232 IN MINT.asm
J_:                 2580 DEFINED AT LINE 1240 IN MINT.asm
KEY_:               258A DEFINED AT LINE 1248 IN MINT.asm
SYSCONST_:          2593 DEFINED AT LINE 1255 IN MINT.asm
LEAST_:             259E DEFINED AT LINE 1263 IN MINT.asm
MOST_:              25A6 DEFINED AT LINE 1271 IN MINT.asm
MOST1:              25AB DEFINED AT LINE 1276 IN MINT.asm
                    > USED AT LINE 1269 IN MINT.asm
MOST2:              25AF DEFINED AT LINE 1280 IN MINT.asm
                    > USED AT LINE 1277 IN MINT.asm
NEWLN_:             25B2 DEFINED AT LINE 1284 IN MINT.asm
OUTPORT_:           25B7 DEFINED AT LINE 1288 IN MINT.asm
ROT_:               25BE DEFINED AT LINE 1295 IN MINT.asm
SIGN_:              25C5 DEFINED AT LINE 1303 IN MINT.asm
SIGN2:              25CE DEFINED AT LINE 1309 IN MINT.asm
                    > USED AT LINE 1307 IN MINT.asm
WHILE_:             25D1 DEFINED AT LINE 1313 IN MINT.asm
WHILE1:             25D8 DEFINED AT LINE 1319 IN MINT.asm
                    > USED AT LINE 1317 IN MINT.asm
EDITDEF_:           25E0 DEFINED AT LINE 1324 IN MINT.asm
PRINTSTK_:          25E2 DEFINED AT LINE 1326 IN MINT.asm
PRINTSTK:           25E2 DEFINED AT LINE 1331 IN MINT.asm
EDITDEF:            2607 DEFINED AT LINE 1340 IN MINT.asm
                    > USED AT LINE 1325 IN MINT.asm
EDITDEF1:           2628 DEFINED AT LINE 1361 IN MINT.asm
                    > USED AT LINE 1367 IN MINT.asm
EDITDEF2:           2629 DEFINED AT LINE 1363 IN MINT.asm
                    > USED AT LINE 1360 IN MINT.asm
EDITDEF3:           2631 DEFINED AT LINE 1368 IN MINT.asm
                    > USED AT LINE 1355 IN MINT.asm
ARRDEF:             263D DEFINED AT LINE 1381 IN MINT.asm
                    > USED AT LINE 698 IN MINT.asm
ARRDEF1:            263F DEFINED AT LINE 1383 IN MINT.asm
                    > USED AT LINE 1128 IN MINT.asm
ARREND:             264F DEFINED AT LINE 1391 IN MINT.asm
                    > USED AT LINE 699 IN MINT.asm
ARREND2:            2664 DEFINED AT LINE 1403 IN MINT.asm
                    > USED AT LINE 1400 IN MINT.asm
DEF:                266B DEFINED AT LINE 1417 IN MINT.asm
                    > USED AT LINE 718 IN MINT.asm
NEXTBYTE:           2680 DEFINED AT LINE 1434 IN MINT.asm
                    > USED AT LINE 1441 IN MINT.asm
END_DEF:            268B DEFINED AT LINE 1443 IN MINT.asm
                    > USED AT LINE 1440 IN MINT.asm
GET_HEX:            2692 DEFINED AT LINE 1451 IN MINT.asm
                    > USED AT LINE 759 IN MINT.asm
GET_HEX1:           2697 DEFINED AT LINE 1456 IN MINT.asm
                    > USED AT LINE 1475 IN MINT.asm
ASCHX1:             269D DEFINED AT LINE 1460 IN MINT.asm
                    > USED AT LINE 1458 IN MINT.asm
TIMES16:            26A7 DEFINED AT LINE 1469 IN MINT.asm
ENDHEX:             26AD DEFINED AT LINE 1477 IN MINT.asm
                    > USED AT LINE 1467 IN MINT.asm
PRINTHEX:           26AE DEFINED AT LINE 1479 IN MINT.asm
                    > USED AT LINE 724 IN MINT.asm
                    > USED AT LINE 764 IN MINT.asm
PRINT_HEX8:         26B9 DEFINED AT LINE 1492 IN MINT.asm
                    > USED AT LINE 1483 IN MINT.asm
                    > USED AT LINE 1485 IN MINT.asm
CONV:               26C2 DEFINED AT LINE 1501 IN MINT.asm
                    > USED AT LINE 1498 IN MINT.asm
NESTING:            26CD DEFINED AT LINE 1519 IN MINT.asm
                    > USED AT LINE 210 IN MINT.asm
                    > USED AT LINE 240 IN MINT.asm
                    > USED AT LINE 1036 IN MINT.asm
NESTING1A:          26D8 DEFINED AT LINE 1526 IN MINT.asm
                    > USED AT LINE 1523 IN MINT.asm
NESTING1:           26DB DEFINED AT LINE 1529 IN MINT.asm
                    > USED AT LINE 1521 IN MINT.asm
NESTING2:           26EA DEFINED AT LINE 1538 IN MINT.asm
                    > USED AT LINE 1533 IN MINT.asm
                    > USED AT LINE 1535 IN MINT.asm
NESTING3:           26EC DEFINED AT LINE 1541 IN MINT.asm
                    > USED AT LINE 1537 IN MINT.asm
NESTING4:           26F7 DEFINED AT LINE 1548 IN MINT.asm
                    > USED AT LINE 1543 IN MINT.asm
                    > USED AT LINE 1545 IN MINT.asm
STACK:              3900 DEFINED AT LINE 4 IN ram.asm
DSTACK:             3900 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 168 IN MINT.asm
                    > USED AT LINE 486 IN MINT.asm
                    > USED AT LINE 1165 IN MINT.asm
RSTACK:             3A00 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 175 IN MINT.asm
TIB:                3A00 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 203 IN MINT.asm
                    > USED AT LINE 235 IN MINT.asm
                    > USED AT LINE 244 IN MINT.asm
                    > USED AT LINE 257 IN MINT.asm
                    > USED AT LINE 487 IN MINT.asm
                    > USED AT LINE 1354 IN MINT.asm
                    > USED AT LINE 1369 IN MINT.asm
MINTVARS:           3B00 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 859 IN MINT.asm
                    > USED AT LINE 1208 IN MINT.asm
                    > USED AT LINE 1424 IN MINT.asm
SYSCONSTS:          3B00 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 178 IN MINT.asm
                    > USED AT LINE 1259 IN MINT.asm
CS0:                3B00 DEFINED AT LINE 20 IN ram.asm
CTIB:               3B02 DEFINED AT LINE 21 IN ram.asm
CDEFS:              3B04 DEFINED AT LINE 22 IN ram.asm
CVARS:              3B06 DEFINED AT LINE 23 IN ram.asm
COPCODES:           3B08 DEFINED AT LINE 24 IN ram.asm
CMACROS:            3B0A DEFINED AT LINE 25 IN ram.asm
CUSERVARS:          3B0C DEFINED AT LINE 26 IN ram.asm
USERVARS:           3B10 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 492 IN MINT.asm
                    > USED AT LINE 1208 IN MINT.asm
VALT:               3B10 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 648 IN MINT.asm
VBASE16:            3B12 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 721 IN MINT.asm
VTIBPTR:            3B14 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 197 IN MINT.asm
                    > USED AT LINE 256 IN MINT.asm
                    > USED AT LINE 359 IN MINT.asm
                    > USED AT LINE 368 IN MINT.asm
                    > USED AT LINE 1373 IN MINT.asm
VHEAPPTR:           3B1E DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 337 IN MINT.asm
                    > USED AT LINE 346 IN MINT.asm
                    > USED AT LINE 1386 IN MINT.asm
                    > USED AT LINE 1395 IN MINT.asm
                    > USED AT LINE 1429 IN MINT.asm
                    > USED AT LINE 1444 IN MINT.asm
VARS:               3B44 DEFINED AT LINE 64 IN ram.asm
                    > USED AT LINE 489 IN MINT.asm
                    > USED AT LINE 859 IN MINT.asm
DEFS:               3B78 DEFINED AT LINE 69 IN ram.asm
                    > USED AT LINE 181 IN MINT.asm
                    > USED AT LINE 488 IN MINT.asm
                    > USED AT LINE 707 IN MINT.asm
                    > USED AT LINE 883 IN MINT.asm
                    > USED AT LINE 1345 IN MINT.asm
                    > USED AT LINE 1419 IN MINT.asm
                    > USED AT LINE 1424 IN MINT.asm
BUF:                3BAC DEFINED AT LINE 71 IN ram.asm
VIFTEMODE:          3C2C DEFINED AT LINE 73 IN ram.asm
                    > USED AT LINE 906 IN MINT.asm
                    > USED AT LINE 1012 IN MINT.asm
                    > USED AT LINE 1180 IN MINT.asm
VBYTEMODE:          3C2E DEFINED AT LINE 74 IN ram.asm
                    > USED AT LINE 339 IN MINT.asm
                    > USED AT LINE 1385 IN MINT.asm
                    > USED AT LINE 1398 IN MINT.asm
RST08:              3C30 DEFINED AT LINE 75 IN ram.asm
RST10:              3C32 DEFINED AT LINE 76 IN ram.asm
RST18:              3C34 DEFINED AT LINE 77 IN ram.asm
RST20:              3C36 DEFINED AT LINE 78 IN ram.asm
RST28:              3C38 DEFINED AT LINE 79 IN ram.asm
RST30:              3C3A DEFINED AT LINE 80 IN ram.asm
BAUD:               3C3C DEFINED AT LINE 81 IN ram.asm
INTVEC:             3C3E DEFINED AT LINE 82 IN ram.asm
NMIVEC:             3C40 DEFINED AT LINE 83 IN ram.asm
GETCVEC:            3C42 DEFINED AT LINE 84 IN ram.asm
                    > USED AT LINE 20
                    > USED AT LINE 29
PUTCVEC:            3C44 DEFINED AT LINE 85 IN ram.asm
                    > USED AT LINE 22
                    > USED AT LINE 34
TBPTR:              3C46 DEFINED AT LINE 86 IN ram.asm
HEAP:               3C80 DEFINED AT LINE 89 IN ram.asm
                    > USED AT LINE 503 IN MINT.asm
